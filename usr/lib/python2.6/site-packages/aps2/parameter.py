import simplejson as json
import ordereddict
import urllib2
import aps2.utils
import re

import aps2.uLogging
import urlparse

STRING = "string"
INTEGER = "integer"
BOOLEAN = "boolean"
NUMBER = "number"

PATH = "path"
QUERY = "query"
BODY = "body"


class Obj(object):
    pass


def str2bool(v):
    return v.lower() in ("true", "t", "1")


def get_obj_by_complex_type(value, type_param, current_structures):
    if type_param.count('#') == 1:
        re_match = re.compile("(?P<aps_type>.*)#(?P<name_structure>.*)").match(type_param)
        aps_type = re_match.group("aps_type")
        name_structure = re_match.group("name_structure")

        schema = aps2.InfoParse.InfoParse.get_aps_api().GET(
            "/aps/2/types/?id=" + aps_type,
            None,
            None,
            aps2.InfoParse.InfoParse.get_pem_path_certificate()
        )[0]
        current_structures = schema

    else:
        assert current_structures, "type isn't valid: " + type_param
        name_structure = type_param
        schema = current_structures

    properties = schema["structures"][name_structure]["properties"]

    aps2.printer.print_json("structure",  schema["structures"][name_structure])

    result = Obj()
    for prop in properties:
        aps2.uLogging.debug("prop = " + prop)
        aps2.uLogging.debug("type = " + schema["structures"][name_structure]["properties"][prop]["type"])
        setattr(result,
                prop,
                get_obj_by_type(
                    value[prop],
                    schema["structures"][name_structure]["properties"][prop]["type"],
                    current_structures)
                )

    return result


def get_obj_by_type(value, type_param, current_structures=None):
    if type_param == STRING:
        return urllib2.unquote(value)
    elif type_param == INTEGER:
        return int(value)
    elif type_param == BOOLEAN:
        return str2bool(value)
    elif type_param == NUMBER:
        return float(value)
    else:
        obj = get_obj_by_complex_type(value, type_param, current_structures)
        return obj


class Argument:
    def __init__(self, name_parameter, value, json):
        self.name = name_parameter
        self.json = json
        self.value = get_obj_by_type(value, json["type"])

    def to_string(self):
        return "name = " + self.name + "\n" \
               + "value = " + str(self.value) + " === " + str(type(self.value)) + "\n" \
               + "json = \n" + json.dumps(self.json, indent=8) + "\n"

    def to_string_without_json(self):
        return "name = " + self.name + "\n" \
               + "value = " + str(self.value) + " === " + str(type(self.value)) + "\n"


def get_arguments(function_description, parsed_environ):
    list_arguments = []
    aps2.uLogging.debug("function_description.json = ")
    aps2.uLogging.debug(function_description.json)
    function_path_pattern = aps2.utils.get_pattern_by_path(function_description.json["path"])
    for param in function_description.json.get("parameters", []):
        aps2.uLogging.debug(param)
        kind_param = function_description.json["parameters"][param]["kind"]
        if kind_param == PATH:
            value = function_path_pattern.match(parsed_environ.get("PATH_INFO")).group(param)
        elif kind_param == QUERY:
            query_dict = dict(urlparse.parse_qsl(parsed_environ.get("QUERY_STRING")))
            value = query_dict[param]
        elif kind_param == BODY:
            value = parsed_environ.get("BODY")
        else:
            raise Exception("Unknown kind of parameter: " + kind_param)
        list_arguments.append(Argument(param, value, function_description.json["parameters"][param]))

    return list_arguments
