import simplejson as json
import ordereddict
import urllib2
import aps2.utils
import re

import aps2.uLogging
import aps2.printer
import urlparse

STRING = "string"
INTEGER = "integer"
BOOLEAN = "boolean"
NUMBER = "number"

PATH = "path"
QUERY = "query"
BODY = "body"


class Obj(object):
    pass


def str2bool(v):
    return v.lower() in ("true", "t", "1")


def get_obj_by_complex_type(value, type_param, controller_client, current_structures):
    aps2.uLogging.debug("get_obj_by_complex_type")
    if type_param.count('#') == 1:
        re_match = re.compile("(?P<aps_type>.*)#(?P<name_structure>.*)").match(type_param)
        aps_type = re_match.group("aps_type")
        name_structure = re_match.group("name_structure")
        aps2.uLogging.debug("aps_type = " + aps_type)
        aps2.uLogging.debug("name_structure = " + name_structure)

        schema = controller_client.get_type(aps_type)[0]

        aps2.printer.print_json("schema = ", schema)

        current_structures = schema

    else:
        assert current_structures, "type isn't valid: " + type_param
        name_structure = type_param
        schema = current_structures

    properties = schema["structures"][name_structure]["properties"]
    aps2.uLogging.debug("properties - ok")

    aps2.printer.print_json("structure", schema["structures"][name_structure])

    result = Obj()
    for prop in properties:
        aps2.uLogging.debug("prop = " + prop)
        aps2.uLogging.debug("type = " + schema["structures"][name_structure]["properties"][prop]["type"])
        setattr(result,
                prop,
                get_obj_by_type(
                    value[prop],
                    schema["structures"][name_structure]["properties"][prop]["type"],
                    controller_client,
                    current_structures
                )
                )

    return result


def get_obj_by_type(value, type_param, controller_client, current_structures=None):
    if type_param == STRING:
        return urllib2.unquote(value)
    elif type_param == INTEGER:
        return int(value)
    elif type_param == BOOLEAN:
        return str2bool(value)
    elif type_param == NUMBER:
        return float(value)
    else:
        obj = get_obj_by_complex_type(value, type_param, controller_client, current_structures)
        return obj


class Argument:
    def __init__(self, name_parameter, value, json, controller_client):
        self.name = name_parameter
        self.json = json
        self.value = get_obj_by_type(value, json["type"], controller_client)

    def to_string(self):
        return "name = " + self.name + "\n" \
               + "value = " + str(self.value) + " === " + str(type(self.value)) + "\n" \
               + "json = \n" + json.dumps(self.json, indent=8) + "\n"

    def to_string_without_json(self):
        return "name = " + self.name + "\n" \
               + "value = " + str(self.value) + " === " + str(type(self.value)) + "\n"


def get_arguments(function_description, parsed_environ, controller_client):
    aps2.printer.print_json("function_description", function_description.json)
    list_arguments = []
    function_path_pattern = aps2.utils.get_pattern_by_path(function_description.json["path"])
    for param in function_description.json.get("parameters", []):
        kind_param = function_description.json["parameters"][param]["kind"]
        aps2.uLogging.debug("param = " + param)
        aps2.uLogging.debug("kind_param = " + kind_param)

        if kind_param == PATH:
            value = re.search(function_path_pattern, parsed_environ.get("PATH_INFO")).group(param)
        elif kind_param == QUERY:
            query_dict = dict(urlparse.parse_qsl(parsed_environ.get("QUERY_STRING")))
            value = query_dict[param]
        elif kind_param == BODY:
            value = parsed_environ.get("BODY")
        else:
            raise Exception("Unknown kind of parameter: " + kind_param)
        list_arguments.append(Argument(param, value, function_description.json["parameters"][param], controller_client))

    return list_arguments
