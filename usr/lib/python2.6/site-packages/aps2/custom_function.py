# import aps2.parameter
import aps2.printer

import json
import re

logger = aps2.uLogging.get_logger('/tmp/myapp.log', aps2.uLogging.DEBUG)

#
# class CustomFunction:
#     # For example:
#     # pattern = re.compile("/createKey/(?P<pathparam>[a-zA-Z][0-9a-zA-Z_]*)/(?P<ps>[a-zA-Z][0-9a-zA-Z_]*)")
#     # main_name = createKeyFunc
#     # json =
#     # #### "createKeyFunc": {
#     #         "verb": "POST",
#     #         "path": "/createKey/{pathparam}/{ps}",
#     #         "response": {
#     #                 "contentType": null,
#     #                 "type": "http://user-mgmt.demo.apsdemo.org/methods/vpses/1.0#OS",
#     #                 "items": null
#     #         },
#     #         "access": {
#     #                 "referrer": true
#     #         },
#     #         "parameters": {
#     #                 "pathparam": {
#     #                         "type": "string",
#     #                         "required": true,
#     #                         "kind": "path"
#     #                 }
#     #         }
#     # ### }
#     # parameters = Parameter()[]
#     def __init__(self):
#         self.main_name = None
#         self.pattern = None
#         self.json = None
#         self.parameters = []
#
#         self.fill_information()
#
#     def fill_information(self):
#         custom_function = self.get_appropriate_custom_function()
#         logger.info("custom_function.main_name = " + custom_function.main_name)
#         logger.info("custom_function.pattern = " + str(custom_function.pattern))
#         logger.info("custom_function.json = " + json.dumps(custom_function.json, indent=8))
#
#         for param in custom_function.get_parameters():
#             logger.info("param.name = " + param.name)
#             aps2.printer.print_json("param.json = ", param.json)
#
#     def get_parameters(self):
#         aps2.printer.print_json("PARAMETERS:", self.json["parameters"])
#         for name_param in self.json["parameters"]:
#             aps2.printer.print_json("name param = ", name_param)
#             parameter = aps2.parameter.Parameter(name_param)
#             parameter.json = self.json["parameters"][name_param]
#             self.parameters.append(parameter)
#         return self.parameters
#
#     def get_appropriate_custom_function(self):
#         # logger.info("schema: ")
#         # logger.info(json.dumps(hpr.schema_json, indent=8))
#         # logger.info("PATH_INFO = + " + hpr.PATH_INFO)
#         # logger.info("func = " + hpr.current_function)
#         valid_custom_functions = self.get_valid_custom_functions()
#         for valid_custom_function in valid_custom_functions:
#             # logger.info("pat = " + str(valid_custom_function.pattern))
#             if self.is_match_for_custom_function(valid_custom_function):
#                 logger.info("is Match!")
#                 return valid_custom_function
#         else:
#             logger.info("is not Match!!")
#             raise Exception("Not found custom valid_custom_function")
#
#     def get_valid_custom_functions(self):
#         list_custom_functions = []
#         for oper in aps2.ServiceId.ServiceId.get_schema_json(self.hpr)["operations"]:
#             path = aps2.ServiceId.ServiceId.get_schema_json(self.hpr)["operations"][oper]["path"]
#             if path.find('{') != -1:
#                 beginning_of_the_path = path[:path.find('{')-1]         # beginning_of_the_path = "/calculateSomething"
#             else:
#                 beginning_of_the_path = path
#             logger.info("beginning_of_the_path = " + beginning_of_the_path)
#             end_of_the_path = path[len(beginning_of_the_path)+1:]       # end_of_the_path = "{pathparam}/{ps}"
#             logger.info("end_of_the_path = " + end_of_the_path)
#             pattern_string = beginning_of_the_path
#             logger.info("pattern_string = " + pattern_string)
#             # function = aps2.custom_function.CustomFunction(self.hpr)
#             for parameter in re.split("/", end_of_the_path):
#                 parameter = parameter[1:len(parameter)-1]
#                 # logger.info("parameter = " + parameter)
#                 # TODO assert valid parameter
#                 # type_param = hpr.schema_json["operations"][oper]["parameters"][parameter]["type"]
#                 # logger.info("type_param = " + type_param)
#                 # function.list_params.append(Parameter(parameter))
#                 pattern_string += "/(?P<" + parameter + ">[a-zA-Z][0-9a-zA-Z_]*)"
#             self.pattern = re.compile(pattern_string)
#             self.json = aps2.ServiceId.ServiceId.get_schema_json(self.hpr)["operations"][oper]
#             self.main_name = str(oper)
#             logger.info("pattern_string = " + pattern_string)
#             logger.info("function.json = ...")
#             logger.info("function.main_name = " + self.main_name)
#             list_custom_functions.append(self)
#         return list_custom_functions
#
#     def add_parameters_from_query_string(self, function):
#         logger.info("QUERY_STRING = " + self.hpr.QUERY_STRING)
#         if not self.hpr.QUERY_STRING:
#             return
#         for parameter in self.hpr.QUERY_STRING.split("&"):
#             assert parameter.count('=') == 1, "Parameter in QUERY_STRING not valid"
#             name = parameter.split("=")[0]
#             value = parameter.split("=")[1]
#             # logger.info("name = " + name)
#             # logger.info("value = " + value)
#             function.list_params.append(aps2.parameter.Parameter(name, value))
#
#     def is_match_for_custom_function(self, valid_custom_function):
#         result_re = valid_custom_function.pattern.match(self.hpr.current_function)
#         if not result_re:
#             return False
#         logger.info("valid_custom_function.json.verb = " + valid_custom_function.json["verb"])
#         if valid_custom_function.json["verb"] != self.hpr.REQUEST_METHOD:
#             return False
#         # TODO add checks: verb and other
#         return True
#
