import pprint
import os
import re

import simplejson as json
import ordereddict

import aps2.call_to_application
import aps2.printer

import aps2.Types
import aps2.ServiceId
import aps2.Info
import aps2.InfoParse
import aps2.Deleter
import aps2.CustomFunction
import aps2.uLogging

from apsapi import logger  # TODO

os.environ['APP_PATH'] = '/usr/local/share/applications/pycloud/'

NF_LIST_SERVICES = 'list_services.json'
STRING = 'string'

def get_constructor():
    class_name = aps2.ServiceId.ServiceId.get_schema_json()["name"]

    tree_appmeta = aps2.Types.Types.get_appmeta_et_root()

    appmeta_namespace = re.search('\{(.*)\}', tree_appmeta.tag).group(1)
    services = tree_appmeta.findall(".//{" + appmeta_namespace + "}service")

    script_path = ""
    for service in services:
        if service.get('id') == aps2.ServiceId.ServiceId.get_name_service_id():
            script_path = service.findall(".//{" + appmeta_namespace + "}code")[0].get('path')  # TODO
            script_path = script_path[script_path.find('/')+1:script_path.rfind('.')]
            break

    # logger.info("class_name = " + class_name)
    # logger.info('script_path = ' + script_path)

    import_script = __import__(script_path)
    constructor = getattr(import_script, class_name)

    return constructor


# call_method_post work post request:
#
# 1. Get request_json (info about host_name, admin_name ... , aps.type, aps.package.href
# You can see request_json with :
#   if request_size:        if

#       logger.info('REQUEST BODY:')
#       logger.info(request_body)
# 2. Save certificate
# 3. Get schema for info about scripts (ex. class_name, properties define in scripts)
# see. clouds.schema.gen
# 5. Create new_resource and fill properties from arrived json (request_json)
# 6. Send new_resource with properties call_provision
# 7. Return new json with properties after provision()
def call_method_post():
    aps2.printer.print_environment(aps2.Info.Info.get_ENVIRON())
    aps2.printer.print_request_body(aps2.Info.Info.get_BODY_JSON())
    aps2.Types.Types.save_certificate()

    # logger.info("schema = ")
    # logger.info(schema)
    # logger.info("schema.name = " + schema.name)

    constructor = get_constructor()
    properties = get_properties(aps2.ServiceId.ServiceId.get_schema_json())

    new_resource = constructor()
    for prop in properties:
        setattr(new_resource, prop, aps2.Info.Info.get_BODY_JSON()[prop])

    logger.info("NEW = " + new_resource.apphost)
    logger.info("NEW = " + new_resource.cloudpass)
    logger.info("NEW = " + new_resource.cloudadmin)

    result = aps2.call_to_application.call_provision(new_resource, properties, aps2.Info.Info.get_BODY_JSON())
    return result


def get_properties(schema):
    properties = []
    json_properties = schema["properties"]
    for prop in json_properties.items():
        # logger.info("1 = " + str(prop[0]))
        properties.append(str(prop[0]))
    return properties


# call_method_delete post request:
#
# 1. Get old_json
# 3. Get schema for info about scripts (ex. class_name, properties define in scripts)
# see. clouds.schema.gen
# 5. Create old_resource and fill properties from arrived json (old_json)
# 6. Send old_resource with properties call_unprovision
# 7. Return new json with properties after unprovision()
def call_method_delete():
    logger.info("aps_id = " + aps2.InfoParse.InfoParse.get_aps_id())
    old_json = aps2.InfoParse.InfoParse.get_aps_api().GET("/aps/2/resources/" + aps2.InfoParse.InfoParse.get_aps_id(), None, None, aps2.InfoParse.InfoParse.get_pem_path_certificate())

    constructor = get_constructor()
    properties = get_properties(aps2.ServiceId.ServiceId.get_schema_json())

    old_resource = constructor()
    for prop in properties:
        setattr(old_resource, prop, old_json[prop])
    logger.info("OLD = " + old_resource.apphost)
    logger.info("OLD = " + old_resource.cloudadmin)
    logger.info("OLD = " + old_resource.cloudpass)

    result = aps2.call_to_application.call_unprovision(old_resource)

    return result


# see post
def call_method_get():
    old_json = aps2.InfoParse.InfoParse.get_aps_api().GET("/aps/2/resources/" + aps2.InfoParse.InfoParse.get_aps_id(), None, None, aps2.InfoParse.InfoParse.get_pem_path_certificate())

    constructor = get_constructor()
    properties = get_properties(aps2.ServiceId.ServiceId.get_schema_json())

    old_resource = constructor()
    for prop in properties:
        setattr(old_resource, prop, old_json[prop])
    logger.info("OLD = " + old_resource.apphost)
    logger.info("OLD = " + old_resource.cloudadmin)
    logger.info("OLD = " + old_resource.cloudpass)

    result = aps2.call_to_application.call_retrieve(old_resource, properties, old_json)

    return result


# see post
def call_method_put():
    # print_request_body(request_body)

    old_json = aps2.InfoParse.InfoParse.get_aps_api().GET("/aps/2/resources/" + aps2.InfoParse.InfoParse.get_aps_id(), None, None, aps2.InfoParse.InfoParse.get_pem_path_certificate())

    constructor = get_constructor()
    properties = get_properties(aps2.ServiceId.ServiceId.get_schema_json())

    old_resource = constructor()
    for prop in properties:
        setattr(old_resource, prop, old_json[prop])
    logger.info("OLD = " + old_resource.apphost)
    logger.info("OLD = " + old_resource.cloudadmin)
    logger.info("OLD = " + old_resource.cloudpass)

    new_resource = constructor()
    for prop in properties:
        setattr(new_resource, prop, aps2.Info.Info.get_BODY_JSON()[prop])
    logger.info("NEW = " + new_resource.apphost)
    logger.info("NEW = " + new_resource.cloudpass)
    logger.info("NEW = " + new_resource.cloudadmin)

    result = aps2.call_to_application.call_configure(old_resource, new_resource, properties, aps2.Info.Info.get_BODY_JSON())

    return result


def call_custom_func():
    logger.info("call_custom_func():")
    logger.info("current_function = " + aps2.InfoParse.InfoParse.get_current_function())

    custom_function = aps2.CustomFunction.CustomFunction()

    old_json = aps2.InfoParse.InfoParse.get_aps_api().GET("/aps/2/resources/" + aps2.InfoParse.InfoParse.get_aps_id(),
                                None, None, aps2.InfoParse.InfoParse.get_pem_path_certificate())
    constructor = get_constructor()

    properties = get_properties(aps2.ServiceId.ServiceId.get_schema_json())
    old_resource = constructor()
    for prop in properties:
        setattr(old_resource, prop, old_json[prop])
    logger.info("call_custom_func : OLD = " + old_resource.apphost)
    logger.info("call_custom_func : OLD = " + old_resource.cloudadmin)
    logger.info("call_custom_func : OLD = " + old_resource.cloudpass)

    result = aps2.call_to_application.call_custom_function(old_resource, custom_function)

    return result


def application(environ, start_response):
    """
    'application' is main function
    :param environ: all information
    :param start_response: for response (ex. 500 Error, 204 Ok, 200 Ok)
    :return: [ str ]
    """

    try:
        global logger
        logger = aps2.uLogging.get_logger('/tmp/myapp.log', aps2.uLogging.DEBUG)
        logger.info("######################_BEGIN_######################")
        result = ''

        aps2.Info.Info.set_environ(environ)
        if not aps2.InfoParse.InfoParse.get_current_function():
            logger.info("It is NOT custom function")
            if aps2.Info.Info.get_REQUEST_METHOD() == 'POST':
                result = call_method_post()
            elif aps2.Info.Info.get_REQUEST_METHOD() == 'DELETE':
                result = call_method_delete()
            elif aps2.Info.Info.get_REQUEST_METHOD() == 'GET':
                result = call_method_get()
            elif aps2.Info.Info.get_REQUEST_METHOD() == 'PUT':
                result = call_method_put()
        else:
            logger.info("It is custom function")
            result = call_custom_func()
        #
        if aps2.Info.Info.get_REQUEST_METHOD() == "DELETE":
            start_response('204 OK', [('Content-type', 'text/plain')])
        else:
            start_response('200 OK', [('Content-type', 'text/plain')])

        logger.info("######################_END_######################")
        aps2.Deleter.delete_information()
        return [result]
    except Exception as e:
        aps2.Deleter.delete_information()
        logger.info("Error: " + str(e))
        start_response('500 Internal Error', [('Content-type', 'text/plain')])
        return ["Error: " + str(e)]
