import pprint
import os
import json
import sys
import re

import xml.etree.ElementTree as ET

import aps2.apsapi
import aps2.aps
import aps2.call_to_application
import aps2.helper

import aps2.uLogging

from apsapi import logger

os.environ['APP_PATH'] = '/usr/local/share/applications/pycloud/'

NF_APP_META = 'APP-META.xml'
NF_LIST_SERVICES = 'list_services.json'
SUFFIX_NF_SCHEMA = '.schema'
STRING = 'string'


class Struct(dict):
    def __getattr__(self, name):
        return self[name]

    def __setattr__(self, name, value):
        self[name] = value

    def __delattr__(self, name):
        del self[name]


def get_request_length(environ):
    try:
        request_body_size = int(environ.get('CONTENT_LENGTH', 0))
    except ValueError:
        request_body_size = 0
    return request_body_size


# save_certificate call from call_method_post
# Save certificate from request_json for using PUT GET DELETE
def save_certificate(request_json):
    self = request_json.aps.x509.self
    controller = request_json.aps.x509.controller

    try:
        dir_config = os.environ['APP_PATH'] + 'config/'
        if not os.path.exists(dir_config):
            os.makedirs(dir_config)
        with open(os.environ['APP_PATH'] + 'config/' + hpr.HTTP_APS_INSTANCE_ID + '.pem', 'w') as outfile:
            outfile.write(self)
        with open(os.environ['APP_PATH'] + 'config/' + hpr.HTTP_APS_INSTANCE_ID + '.apsc.pem', 'w') as outfile:
            outfile.write(controller)
    except OSError:
        raise Exception("Cannot make directory 'config/'")
    except IOError:
        raise Exception("Certificate cannot open")


def get_appmeta(json_data):
    if os.path.isfile(os.environ['APP_PATH'] + NF_APP_META):
        tree_appmeta = ET.parse(os.environ['APP_PATH'] + NF_APP_META)
    else:
        uri_appmeta = json_data.aps.package.href + '/APP-META.xml'
        tree_appmeta = hpr.APS_API.GET(uri_appmeta, None, None, hpr.PATH_CERTIFICATE, False)
        # this 'write' write tree_appmeta with prefix = 'ns0'
        tree_appmeta.write(os.environ['APP_PATH'] + NF_APP_META)
    return tree_appmeta.getroot()


def get_constructor(json_data):
    class_name = hpr.schema.name
   
    tree_appmeta = get_appmeta(json_data)

    appmeta_namespace = re.search('\{(.*)\}', tree_appmeta.tag).group(1)
    services = tree_appmeta.findall(".//{" + appmeta_namespace + "}service")

    service_id = hpr.service_id

    script_path = ""
    for service in services:
        if service.get('id') == service_id.main_name:
            script_path = service.findall(".//{" + appmeta_namespace + "}code")[0].get('path')  # TODO
            script_path = script_path[script_path.find('/')+1:script_path.rfind('.')]
            break

    # logger.info("class_name = " + class_name)
    # logger.info('script_path = ' + script_path)

    import_script = __import__(script_path)
    constructor = getattr(import_script, class_name)       
    
    return constructor


def get_application_services():
    if os.path.isfile(os.environ['APP_PATH'] + NF_LIST_SERVICES):
        # logger.info("list_services.json EXIST!")
        with open(os.environ['APP_PATH'] + NF_LIST_SERVICES) as inFile:
            list_services = json.loads(inFile.read(), object_hook=lambda x: aps2.apsapi.JsonNode(**x))
    else:
        # logger.info("list_services.json NOT exist!")
        list_services = hpr.APS_API.GET('/aps/2/application', None, None, hpr.PATH_CERTIFICATE)
        with open(os.environ['APP_PATH'] + NF_LIST_SERVICES, 'wb') as outfile:
            outfile.write(u'%s' % list_services)
    return list_services


def get_service_id():
    list_services = get_application_services()

    # print_list_services(list_services)

    service_id = None
    for item in list_services:
        logger.info("item = " + item)
        pattern = re.compile('/' + item)
        if pattern.match(hpr.PATH_INFO):
            service_id = list_services[item]
            service_id.main_name = item
            break

    # logger.info("list_services: aps_id = " + list_services.aps.id)
    if service_id is None:
        raise Exception("Error: service_id in PATH_INFO not exist!")
    return service_id


def get_schema():
    dir_schemas = os.environ['APP_PATH'] + 'schemas/'
    if not os.path.exists(dir_schemas):
        os.makedirs(dir_schemas)

    nf_schema = hpr.service_id.main_name + SUFFIX_NF_SCHEMA
    if os.path.isfile(dir_schemas + nf_schema):
        # logger.info(nf_schema + " EXIST!")
        with open(dir_schemas + nf_schema) as infile:
            schema = json.loads(infile.read(), object_hook=lambda x: aps2.apsapi.JsonNode(**x))
    else:
        # logger.info(nf_schema + " NOT exist!")
        schema = hpr.APS_API.GET("/aps/2/types/?id=" + hpr.service_id.type, None, None, hpr.PATH_CERTIFICATE)
        with open(dir_schemas + nf_schema, 'wb') as outfile:
            outfile.write('%s' % schema)

    return schema[0]


# call_method_post work post request:
#
# 1. Get request_json (info about host_name, admin_name ... , aps.type, aps.package.href
# You can see request_json with :
#   if request_size:        if

#       logger.info('REQUEST BODY:')
#       logger.info(request_body)
# 2. Save certificate
# 3. Get schema for info about scripts (ex. class_name, properties define in scripts)
# see. clouds.schema.gen 
# 5. Create new_resource and fill properties from arrived json (request_json)
# 6. Send new_resource with properties call_provision
# 7. Return new json with properties after provision()   
def call_method_post():
    request_size = get_request_length(hpr.environ)
    request_body = hpr.environ['wsgi.input'].read(request_size)

    # request_json = json.loads(request_body, object_hook=lambda x: aps2.apsapi.JsonNode(**x))
    request_json = json.loads(request_body, object_hook=Struct)

    print_environment(hpr.environ)
    print_request_body(request_body)
    save_certificate(request_json)

    # logger.info("schema = ")
    # logger.info(schema)
    # logger.info("schema.name = " + schema.name)

    constructor = get_constructor(request_json)
    properties = get_properties(hpr.schema)

    new_resource = constructor()
    for prop in properties:
        setattr(new_resource, prop, request_json[prop])

    logger.info("NEW = " + new_resource.apphost)
    logger.info("NEW = " + new_resource.cloudpass)
    logger.info("NEW = " + new_resource.cloudadmin)
        
    result = aps2.call_to_application.call_provision(new_resource, properties, request_json)
    return result


def get_properties(schema):
    properties = []
    json_properties = json.loads(str(schema.properties))
    for prop in json_properties.items():
        properties.append(str(prop[0]))
    return properties


# call_method_delete post request:
#
# 1. Get old_json   
# 3. Get schema for info about scripts (ex. class_name, properties define in scripts)
# see. clouds.schema.gen 
# 5. Create old_resource and fill properties from arrived json (old_json)
# 6. Send old_resource with properties call_unprovision
# 7. Return new json with properties after unprovision()   
def call_method_delete():
    logger.info("aps_id = " + hpr.aps_id)
    old_json = hpr.APS_API.GET("/aps/2/resources/" + hpr.aps_id, None, None, hpr.PATH_CERTIFICATE)

    constructor = get_constructor(old_json)
    properties = get_properties(hpr.schema)

    old_resource = constructor()
    for prop in properties:
        setattr(old_resource, prop, old_json[prop])
    logger.info("OLD = " + old_resource.apphost)
    logger.info("OLD = " + old_resource.cloudadmin)
    logger.info("OLD = " + old_resource.cloudpass)
   
    result = aps2.call_to_application.call_unprovision(old_resource)

    return result


# see post
def call_method_get():
    old_json = hpr.APS_API.GET("/aps/2/resources/" + hpr.aps_id, None, None, hpr.PATH_CERTIFICATE)

    constructor = get_constructor(old_json)
    properties = get_properties(hpr.schema)

    old_resource = constructor()
    for prop in properties:
        setattr(old_resource, prop, old_json[prop])
    logger.info("OLD = " + old_resource.apphost)
    logger.info("OLD = " + old_resource.cloudadmin)
    logger.info("OLD = " + old_resource.cloudpass)
   
    result = aps2.call_to_application.call_retrieve(old_resource, properties, old_json)

    return result


# see post
def call_method_put():
    request_size = get_request_length(hpr.environ)
    request_body = hpr.environ['wsgi.input'].read(request_size)
    # request_json = json.loads(request_body, object_hook=lambda x: aps2.apsapi.JsonNode(**x))
    request_json = json.loads(request_body, object_hook=Struct)
    
    # print_request_body(request_body)

    old_json = hpr.APS_API.GET("/aps/2/resources/" + hpr.aps_id, None, None, hpr.PATH_CERTIFICATE)

    constructor = get_constructor(old_json)
    properties = get_properties(hpr.schema)

    old_resource = constructor()
    for prop in properties:
        setattr(old_resource, prop, old_json[prop])
    logger.info("OLD = " + old_resource.apphost)
    logger.info("OLD = " + old_resource.cloudadmin)
    logger.info("OLD = " + old_resource.cloudpass)
   
    new_resource = constructor()
    for prop in properties:
        setattr(new_resource, prop, request_json[prop])
    logger.info("NEW = " + new_resource.apphost)
    logger.info("NEW = " + new_resource.cloudpass)
    logger.info("NEW = " + new_resource.cloudadmin)
        
    result = aps2.call_to_application.call_configure(old_resource, new_resource, properties, request_json)

    return result


def print_environment(environ):
    logger.info('REQUEST ENVIRONMENT:')
    logger.info(pprint.pformat(environ))


def print_request_body(request_body):
    logger.info("REQUEST BODY:") 
    logger.info(request_body)


def print_list_services(list_services):
    logger.info("LIST_SERVICES:")
    logger.info(list_services)


def get_aps_id():
    len_service_id = len('/' + hpr.service_id.main_name + '/')
    if len_service_id > len(hpr.PATH_INFO):
        # logger.info("length /service_id/ > len(hpr.PATH_INFO)")
        # logger.info("=> PATH_INFO not consist aps_id")
        return None
    string_without_service_id = hpr.PATH_INFO[len_service_id:]
    # logger.info("string_without_service_id = " + string_without_service_id)
    pattern = re.compile('[\w-]{36}')
    if pattern.match(string_without_service_id):
        aps_id = string_without_service_id[:36]
        # logger.info("aps_id = " + aps_id)
        return aps_id

    return None


def get_func():
    # logger.info("PATH_INFO = " + hpr.PATH_INFO)
    # logger.info("service_id = " + hpr.service_id.main_name)
    if hpr.aps_id:
        # logger.info("aps_id set :)")
        # logger.info("aps_id = " + hpr.aps_id)
        len_service_id_aps_id = len('/' + hpr.service_id.main_name + '/' + hpr.aps_id)
        # logger.info("len_service_id_aps_id = %d " % len_service_id_aps_id)
        func = hpr.PATH_INFO[len_service_id_aps_id:]
    else:
        # logger.info("aps_id not set")
        len_service_id = len('/' + hpr.service_id.main_name + '/')
        # logger.info("len_service_id = %d " % len_service_id)
        func = hpr.PATH_INFO[len_service_id:]
    return func


class Parameter:
    def __init__(self, name_parameter=None, value_parameter=None):
        self.name = name_parameter
        self.value = value_parameter


class CustomFunction:
    def __init__(self):
        self.json = None
        self.call_name = None
        self.list_params = []
        self.pattern = None
        self.params_values = {}


def get_list_valid_custom_functions():
    list_custom_functions = []
    for oper in hpr.schema.operations:
        path = hpr.schema.operations[oper].path
        if path.find('{') != -1:
            without_params = path[:path.find('{')-1]
        else:
            without_params = path
        string_parameters = path[len(without_params)+1:]
        pattern_string = without_params
        function = CustomFunction()
        for parameter in re.split("/", string_parameters):
            parameter = parameter[1:len(parameter)-1]
            # logger.info("parameter = " + parameter)
            # TODO assert valid parameter
            type = hpr.schema.operations[oper].parameters[parameter].type
            # logger.info("type = " + type)
            function.list_params.append(Parameter(parameter))
            if type == STRING:
                pattern_string += "/(?P<" + parameter + ">[a-zA-Z][0-9a-zA-Z_]*)"
        logger.info("pattern_string = " + pattern_string)
        function.pattern = re.compile(pattern_string)
        function.json = hpr.schema.operations[oper]
        function.call_name = str(oper)
        list_custom_functions.append(function)
    return list_custom_functions


def add_parameters_from_query_string(function):
    logger.info("QUERY_STRING = " + hpr.QUERY_STRING)
    for parameter in hpr.QUERY_STRING.split("&"):
        assert parameter.count('=') == 1, "Parameter in QUERY_STRONG not valid"
        name = parameter.split("=")[0]
        value = parameter.split("=")[1]
        # logger.info("name = " + name)
        # logger.info("value = " + value)
        function.list_params.append(Parameter(name, value))


def call_custom_func():
    # logger.info("schema: ")
    # logger.info(hpr.schema)
    # logger.info("PATH_INFO = + " + hpr.PATH_INFO)
    # logger.info("func = " + hpr.func)
    list_valid_custom_functions = get_list_valid_custom_functions()
    # arguments = []
    for function in list_valid_custom_functions:
        # logger.info("pat = " + str(function.pattern))
        result_re = function.pattern.match(hpr.func)
        if result_re:  # TODO add checks: verb and other
            current_custom_function = function
            break
    else:
        raise Exception("Not found custom function")

    for parameter in current_custom_function.list_params:
        string_parameter = result_re.group(parameter.name)
        logger.info(parameter.name + " = " + string_parameter)
        parameter.value = string_parameter
    # logger.info("json = " + str(function.json))
    # logger.info("call_name = " + function.call_name)
    add_parameters_from_query_string(current_custom_function)

    # ###
    # logger.info("check!!")
    # for par in current_custom_function.list_params:
    #     logger.info("par = " + par.name)
    #     logger.info("par = " + par.value)
    # ###

    old_json = hpr.APS_API.GET("/aps/2/resources/" + hpr.aps_id,
                               None, None, hpr.PATH_CERTIFICATE)
    constructor = get_constructor(old_json)

    properties = get_properties(hpr.schema)
    old_resource = constructor()
    for prop in properties:
        setattr(old_resource, prop, old_json[prop])
    # logger.info("call_custom_func : OLD = " + old_resource.apphost)
    # logger.info("call_custom_func : OLD = " + old_resource.cloudadmin)
    # logger.info("call_custom_func : OLD = " + old_resource.cloudpass)

    result = aps2.call_to_application.call_custom_function(old_resource, current_custom_function)

    logger.info(result)

    return result


# 'application' is main function
# environ is all info. You can see info with:
#    logger.info('REQUEST ENVIRONMENT:')
#    logger.info(pprint.pformat(environ))
# 
# 'start_response' for response (ex. 500 Error, 204 Ok, 200 Ok)
def application(environ, start_response):

    try:
        global logger
        logger = aps2.uLogging.get_logger('/tmp/myapp.log', aps2.uLogging.DEBUG)

        logger.info("----------------------------------------------------")

        result = ''
        # print_environment(environ)

        global hpr
        hpr = aps2.helper.Helper()
        hpr.put_environ(environ)

        hpr.service_id = get_service_id()
        hpr.aps_id = get_aps_id()
        hpr.func = get_func()
        hpr.schema = get_schema()

        if not hpr.func:
            logger.info("it is NOT custom function")
            if hpr.REQUEST_METHOD == 'POST':
                result = call_method_post()
            elif hpr.REQUEST_METHOD == 'DELETE':
                result = call_method_delete()
            elif hpr.REQUEST_METHOD == 'GET':
                result = call_method_get()
            elif hpr.REQUEST_METHOD == 'PUT':
                result = call_method_put()
        else:
            logger.info("it is custom function")
            logger.info("func = " + hpr.func)
            result = call_custom_func()

        if hpr.REQUEST_METHOD == "DELETE":
            start_response('204 OK', [('Content-type', 'text/plain')])
        else:
            start_response('200 OK', [('Content-type', 'text/plain')])

        logger.info("----------------------------------------------------")
        return [result]
    except Exception as e:
        logger.info("Error: " + str(e))
        start_response('500 Internal Error', [('Content-type', 'text/plain')])
        return ["Error: " + str(e)]
