import pprint
import os
import json
import sys
import re

import xml.etree.ElementTree as ET

import aps2.apsapi
import aps2.aps
import aps2.call_to_application
import aps2.helper

import aps2.uLogging

os.environ['APP_PATH'] = '/usr/local/share/applications/pycloud/'
APP_META_XML = 'APP-META.xml'
NF_LIST_SERVICES = 'list_services.json'


class Struct(dict):
    def __getattr__(self, name):
        return self[name]

    def __setattr__(self, name, value):
        self[name] = value

    def __delattr__(self, name):
        del self[name]


def get_request_length(environ):
    try:
        request_body_size = int(environ.get('CONTENT_LENGTH', 0))
    except ValueError:
        request_body_size = 0
    return request_body_size


# save_certificate call from call_method_post
# Save certificate from request_json for using PUT GET DELETE
def save_certificate(environ, request_json):
    self = request_json.aps.x509.self
    controller = request_json.aps.x509.controller

    try:
        dir_config = os.environ['APP_PATH'] + 'config/'
        if not os.path.exists(dir_config):
            os.makedirs(dir_config)
        f = open(os.environ['APP_PATH'] + 'config/' + HTTP_APS_INSTANCE_ID + '.pem', 'w')
        f.write(self)
        f.close()
        f = open(os.environ['APP_PATH'] + 'config/' + HTTP_APS_INSTANCE_ID + '.apsc.pem', 'w')
        f.write(controller)
        f.close()
    except OSError:
        logger.info("Cannot make directory 'config/'")
    except IOError:
        logger.info("Certificate cannot open")


# get_information create global properties for using
def get_information(environ):
    global METHOD
    METHOD = environ.get('REQUEST_METHOD', 0)
    
    global REQUEST_URI
    REQUEST_URI = environ.get('REQUEST_URI', 0)
    
    global SCRIPT_NAME
    SCRIPT_NAME = environ.get('SCRIPT_NAME', 0)
    
    global HTTP_APS_CONTROLLER_URI
    HTTP_APS_CONTROLLER_URI = environ.get('HTTP_APS_CONTROLLER_URI', 0)
    if not HTTP_APS_CONTROLLER_URI:
        raise Exception("APS-Controller-URI header is not set")

    global HTTP_APS_INSTANCE_ID
    HTTP_APS_INSTANCE_ID = environ.get('HTTP_APS_INSTANCE_ID', 0)
    if not HTTP_APS_INSTANCE_ID:
        raise Exception("APS Instance ID header is not set!")

    global logger
    logger = aps2.uLogging.getLogger('/tmp/myapp.log', aps2.uLogging.DEBUG)
    
    global APS_API
    APS_API = aps2.apsapi.API(HTTP_APS_CONTROLLER_URI)

    global PATH_CERTIFICATE
    PATH_CERTIFICATE = os.environ['APP_PATH'] + '/config/' + str(HTTP_APS_INSTANCE_ID) + '.pem'

    global PATH_INFO
    PATH_INFO = environ.get('PATH_INFO', 0)


def get_appmeta(json_data):
    if os.path.isfile(os.environ['APP_PATH'] + APP_META_XML):
        tree_appmeta = ET.parse(os.environ['APP_PATH'] + APP_META_XML)
    else:
        uri_appmeta = json_data.aps.package.href + '/APP-META.xml'
        tree_appmeta = APS_API.GET(uri_appmeta, None, None, PATH_CERTIFICATE, False)
        # this 'write' write tree_appmeta with prefix = 'ns0'
        tree_appmeta.write(os.environ['APP_PATH'] + APP_META_XML)
    return tree_appmeta.getroot()


def get_application_services():
    if os.path.isfile(os.environ['APP_PATH'] + 'list_services.json'):
        # logger.info("list_services.json EXIST!")
        with open(os.environ['APP_PATH'] + 'list_services.json') as inFile:
            list_services = json.loads(inFile.read(), object_hook=lambda x: aps2.apsapi.JsonNode(**x))
    else:
        # logger.info("list_services.json NOT exist!")
        list_services = APS_API.GET('/aps/2/application', None, None, PATH_CERTIFICATE)
        with open(os.environ['APP_PATH'] + 'list_services.json', 'wb') as outfile:
            outfile.write(u'%s' % list_services)
    return list_services


def get_constructor(schema, json_data):
    class_name = schema[0].name
   
    tree_appmeta = get_appmeta(json_data)

    appmeta_namespace = re.search('\{(.*)\}', tree_appmeta.tag).group(1)
    services = tree_appmeta.findall(".//{" + appmeta_namespace + "}service")

    service_id = REQUEST_URI[len(SCRIPT_NAME)+1:]
    if '/' in service_id:
        service_id = service_id[:service_id.find('/')]
    # logger.info("service_id = " + service_id)
    
    script_path = ""
    for service in services:
        if service.get('id') == service_id:
            script_path = service.findall(".//{" + appmeta_namespace + "}code")[0].get('path')
            script_path = script_path[script_path.find('/')+1:script_path.rfind('.')]
            break

    # logger.info("class_name = " + class_name)
    # logger.info('script_path = ' + script_path)

    import_script = __import__(script_path)
    constructor = getattr(import_script, class_name)       
    
    return constructor


# call_method_post work post request:
#
# 1. Get request_json (info about host_name, admin_name ... , aps.type, aps.package.href
# You can see request_json with :
#   if request_size:
#       logger.info('REQUEST BODY:')
#       logger.info(request_body)
# 2. Save certificate
# 3. Get schema for info about scripts (ex. class_name, properties define in scripts)
# see. clouds.schema.gen 
# 5. Create new_resource and fill properties from arrived json (request_json)
# 6. Send new_resource with properties call_provision
# 7. Return new json with properties after provision()   
def call_method_post(environ):
    request_size = get_request_length(environ)
    request_body = environ['wsgi.input'].read(request_size)

    #request_json = json.loads(request_body, object_hook=lambda x: aps2.apsapi.JsonNode(**x))
    request_json = json.loads(request_body, object_hook=Struct)
    
    print_request_body(request_body)
    save_certificate(environ, request_json)

    # -----------------------------------
    list_services = get_application_services()

    print_list_services(list_services)

    logger.info("list_services: aps_id = " + list_services.aps.id)
    # -----------------------------------

    logger.info("request_json.aps.type = " + request_json.aps.type)
    schema = APS_API.GET("/aps/2/types/?id=" + request_json.aps.type, None, None, PATH_CERTIFICATE)
    # logger.info("schema[0] = ")
    # logger.info(schema[0])
    # logger.info("schema.name = " + schema[0].name)

    constructor = get_constructor(schema, request_json)
    properties = get_properties(schema)

    new_resource = constructor()
    for prop in properties:
        setattr(new_resource, prop, request_json[prop])

    logger.info("NEW = " + new_resource.apphost)
    logger.info("NEW = " + new_resource.cloudpass)
    logger.info("NEW = " + new_resource.cloudadmin)
        
    result = aps2.call_to_application.call_provision(new_resource, properties, request_json)

    return result


def get_properties(schema):
    properties = []
    json_properties = json.loads(str(schema[0].properties))
    for prop in json_properties.items():
        properties.append(str(prop[0]))
    return properties


# call_method_delete post request:
#
# 1. Get old_json   
# 3. Get schema for info about scripts (ex. class_name, properties define in scripts)
# see. clouds.schema.gen 
# 5. Create old_resource and fill properties from arrived json (old_json)
# 6. Send old_resource with properties call_unprovision
# 7. Return new json with properties after unprovision()   
def call_method_delete(environ):
    aps_id = REQUEST_URI[len(SCRIPT_NAME)+1:]
    aps_id = aps_id[aps_id.find('/')+1:]
 
    # logger.info("aps_id = " + aps_id)
    old_json = APS_API.GET("/aps/2/resources/" + aps_id, None, None, PATH_CERTIFICATE)
    schema = APS_API.GET("/aps/2/types/?id=" + old_json.aps.type, None, None, PATH_CERTIFICATE)
    
    constructor = get_constructor(schema, old_json)
    properties = get_properties(schema)

    old_resource = constructor()
    for prop in properties:
        setattr(old_resource, prop, old_json[prop])
    logger.info("OLD = " + old_resource.apphost)
    logger.info("OLD = " + old_resource.cloudadmin)
    logger.info("OLD = " + old_resource.cloudpass)
   
    result = aps2.call_to_application.call_unprovision(old_resource)

    return result


# see post
def call_method_get(environ):
    aps_id = REQUEST_URI[len(SCRIPT_NAME)+1:]
    aps_id = aps_id[aps_id.find('/')+1:]
 
    old_json = APS_API.GET("/aps/2/resources/" + aps_id, None, None, PATH_CERTIFICATE)
    schema = APS_API.GET("/aps/2/types/?id=" + old_json.aps.type, None, None, PATH_CERTIFICATE)
    
    constructor = get_constructor(schema, old_json)
    properties = get_properties(schema)

    old_resource = constructor()
    for prop in properties:
        setattr(old_resource, prop, old_json[prop])
    logger.info("OLD = " + old_resource.apphost)
    logger.info("OLD = " + old_resource.cloudadmin)
    logger.info("OLD = " + old_resource.cloudpass)
   
    result = aps2.call_to_application.call_retrieve(old_resource, properties, old_json)

    return result


# see post
def call_method_put(environ):
    request_size = get_request_length(environ)
    request_body = environ['wsgi.input'].read(request_size)
    # request_json = json.loads(request_body, object_hook=lambda x: aps2.apsapi.JsonNode(**x))
    request_json = json.loads(request_body, object_hook=Struct)
    
    # print_request_body(request_body)

    aps_id = request_json.aps.id
 
    old_json = APS_API.GET("/aps/2/resources/" + aps_id, None, None, PATH_CERTIFICATE)
    schema = APS_API.GET("/aps/2/types/?id=" + old_json.aps.type, None, None, PATH_CERTIFICATE)
   
    constructor = get_constructor(schema, old_json)
    properties = get_properties(schema)

    old_resource = constructor()
    for prop in properties:
        setattr(old_resource, prop, old_json[prop])
    logger.info("OLD = " + old_resource.apphost)
    logger.info("OLD = " + old_resource.cloudadmin)
    logger.info("OLD = " + old_resource.cloudpass)
   
    new_resource = constructor()
    for prop in properties:
        setattr(new_resource, prop, request_json[prop])
    logger.info("NEW = " + new_resource.apphost)
    logger.info("NEW = " + new_resource.cloudpass)
    logger.info("NEW = " + new_resource.cloudadmin)
        
    result = aps2.call_to_application.call_configure(old_resource, new_resource, properties, request_json)

    return result


def print_environment(environ):
    logger.info('REQUEST ENVIRONMENT:')
    logger.info(pprint.pformat(environ))


def print_request_body(request_body):
    logger.info("REQUEST BODY:") 
    logger.info(request_body)


def print_list_services(list_services):
    logger.info("LIST_SERVICES:")
    logger.info(list_services)


# 'application' is main function
# environ is all info. You can see info with:
#    logger.info('REQUEST ENVIRONMENT:')
#    logger.info(pprint.pformat(environ))
# 
# 'start_response' for response (ex. 500 Error, 204 Ok, 200 Ok)
def application(environ, start_response):

    get_information(environ)    
    
    logger.info("----------------------------------------------------")
    print_environment(environ)

    result = ''

    # if environ.get('QUERY_STRING', 0) == '':
    #     result = call_method_get(environ)
    # else:
    #     logger.info("Not simple Get request!!")

    try:
        if METHOD == 'POST':
            result = call_method_post(environ)
        elif METHOD == 'DELETE':
            result = call_method_delete(environ)
        elif METHOD == 'GET':
            result = call_method_get(environ)
        elif METHOD == 'PUT':
            result = call_method_put(environ)
    except Exception as e:
        start_response('500 Internal Error', [('Content-type', 'text/plain')])
        return ["Error: "+str(e)]
        
    if METHOD == "DELETE":
        start_response('204 OK', [('Content-type', 'text/plain')])
    else:
        start_response('200 OK', [('Content-type', 'text/plain')])
    
    logger.info("----------------------------------------------------")
    return [result]
