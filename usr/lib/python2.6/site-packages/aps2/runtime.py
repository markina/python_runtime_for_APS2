import pprint
import os
import json
import sys
import re

import xml.etree.ElementTree as ET

import aps2.apsapi
import aps2.aps
import aps2.call_to_application
import aps2.helper

import aps2.uLogging
from apsapi import logger

os.environ['APP_PATH'] = '/usr/local/share/applications/pycloud/'

NF_APP_META = 'APP-META.xml'
NF_LIST_SERVICES = 'list_services.json'
SUFFIX_NF_SCHEMA = '.schema'


class Struct(dict):
    def __getattr__(self, name):
        return self[name]

    def __setattr__(self, name, value):
        self[name] = value

    def __delattr__(self, name):
        del self[name]


def get_request_length(environ):
    try:
        request_body_size = int(environ.get('CONTENT_LENGTH', 0))
    except ValueError:
        request_body_size = 0
    return request_body_size


# save_certificate call from call_method_post
# Save certificate from request_json for using PUT GET DELETE
def save_certificate(request_json):
    self = request_json.aps.x509.self
    controller = request_json.aps.x509.controller

    try:
        dir_config = os.environ['APP_PATH'] + 'config/'
        if not os.path.exists(dir_config):
            os.makedirs(dir_config)
        with open(os.environ['APP_PATH'] + 'config/' + hpr.HTTP_APS_INSTANCE_ID + '.pem', 'w') as outfile:
            outfile.write(self)
        with open(os.environ['APP_PATH'] + 'config/' + hpr.HTTP_APS_INSTANCE_ID + '.apsc.pem', 'w') as outfile:
            outfile.write(controller)
    except OSError:
        raise Exception("Cannot make directory 'config/'")
    except IOError:
        raise Exception("Certificate cannot open")


def get_appmeta(json_data):
    if os.path.isfile(os.environ['APP_PATH'] + NF_APP_META):
        tree_appmeta = ET.parse(os.environ['APP_PATH'] + NF_APP_META)
    else:
        uri_appmeta = json_data.aps.package.href + '/APP-META.xml'
        tree_appmeta = hpr.APS_API.GET(uri_appmeta, None, None, hpr.PATH_CERTIFICATE, False)
        # this 'write' write tree_appmeta with prefix = 'ns0'
        tree_appmeta.write(os.environ['APP_PATH'] + NF_APP_META)
    return tree_appmeta.getroot()


def get_constructor(json_data):
    class_name = hpr.schema.name
   
    tree_appmeta = get_appmeta(json_data)

    appmeta_namespace = re.search('\{(.*)\}', tree_appmeta.tag).group(1)
    services = tree_appmeta.findall(".//{" + appmeta_namespace + "}service")

    service_id = hpr.service_id

    script_path = ""
    for service in services:
        if service.get('id') == service_id.main_name:
            script_path = service.findall(".//{" + appmeta_namespace + "}code")[0].get('path')  # TODO
            script_path = script_path[script_path.find('/')+1:script_path.rfind('.')]
            break

    # logger.info("class_name = " + class_name)
    # logger.info('script_path = ' + script_path)

    import_script = __import__(script_path)
    constructor = getattr(import_script, class_name)       
    
    return constructor


def get_application_services():
    if os.path.isfile(os.environ['APP_PATH'] + NF_LIST_SERVICES):
        # logger.info("list_services.json EXIST!")
        with open(os.environ['APP_PATH'] + NF_LIST_SERVICES) as inFile:
            list_services = json.loads(inFile.read(), object_hook=lambda x: aps2.apsapi.JsonNode(**x))
    else:
        # logger.info("list_services.json NOT exist!")
        list_services = hpr.APS_API.GET('/aps/2/application', None, None, hpr.PATH_CERTIFICATE)
        with open(os.environ['APP_PATH'] + NF_LIST_SERVICES, 'wb') as outfile:
            outfile.write(u'%s' % list_services)
    return list_services


def get_service_id():
    list_services = get_application_services()

    # print_list_services(list_services)

    service_id = None
    for item in list_services:
        logger.info("item = " + item)
        pattern = re.compile('/' + item)
        if pattern.match(hpr.PATH_INFO):
            service_id = list_services[item]
            service_id.main_name = item
            break

    # logger.info("list_services: aps_id = " + list_services.aps.id)
    if service_id is None:
        raise Exception("Error: service_id in PATH_INFO not exist!")
    return service_id


def get_schema():
    dir_schemas = os.environ['APP_PATH'] + 'schemas/'
    if not os.path.exists(dir_schemas):
        os.makedirs(dir_schemas)

    nf_schema = hpr.service_id.main_name + SUFFIX_NF_SCHEMA
    if os.path.isfile(dir_schemas + nf_schema):
        # logger.info(nf_schema + " EXIST!")
        with open(dir_schemas + nf_schema) as infile:
            schema = json.loads(infile.read(), object_hook=lambda x: aps2.apsapi.JsonNode(**x))
    else:
        # logger.info(nf_schema + " NOT exist!")
        schema = hpr.APS_API.GET("/aps/2/types/?id=" + hpr.service_id.type, None, None, hpr.PATH_CERTIFICATE)
        with open(dir_schemas + nf_schema, 'wb') as outfile:
            outfile.write('%s' % schema)

    return schema[0]


# call_method_post work post request:
#
# 1. Get request_json (info about host_name, admin_name ... , aps.type, aps.package.href
# You can see request_json with :
#   if request_size:        if

#       logger.info('REQUEST BODY:')
#       logger.info(request_body)
# 2. Save certificate
# 3. Get schema for info about scripts (ex. class_name, properties define in scripts)
# see. clouds.schema.gen 
# 5. Create new_resource and fill properties from arrived json (request_json)
# 6. Send new_resource with properties call_provision
# 7. Return new json with properties after provision()   
def call_method_post():
    request_size = get_request_length(hpr.environ)
    request_body = hpr.environ['wsgi.input'].read(request_size)

    # request_json = json.loads(request_body, object_hook=lambda x: aps2.apsapi.JsonNode(**x))
    request_json = json.loads(request_body, object_hook=Struct)
    
    print_request_body(request_body)
    save_certificate(request_json)

    # logger.info("schema = ")
    # logger.info(schema)
    # logger.info("schema.name = " + schema.name)

    constructor = get_constructor(request_json)
    properties = get_properties(hpr.schema)

    new_resource = constructor()
    for prop in properties:
        setattr(new_resource, prop, request_json[prop])

    logger.info("NEW = " + new_resource.apphost)
    logger.info("NEW = " + new_resource.cloudpass)
    logger.info("NEW = " + new_resource.cloudadmin)
        
    result = aps2.call_to_application.call_provision(new_resource, properties, request_json)
    return result


def get_properties(schema):
    properties = []
    json_properties = json.loads(str(schema.properties))
    for prop in json_properties.items():
        properties.append(str(prop[0]))
    return properties


# call_method_delete post request:
#
# 1. Get old_json   
# 3. Get schema for info about scripts (ex. class_name, properties define in scripts)
# see. clouds.schema.gen 
# 5. Create old_resource and fill properties from arrived json (old_json)
# 6. Send old_resource with properties call_unprovision
# 7. Return new json with properties after unprovision()   
def call_method_delete():
    # aps_id = hpr.REQUEST_URI[len(hpr.SCRIPT_NAME)+1:]
    # aps_id = aps_id[aps_id.find('/')+1:]

    # if not hpr.aps_id:
    #     raise Exception("Error: aps_id is not set")
 
    logger.info("aps_id = " + hpr.aps_id)
    old_json = hpr.APS_API.GET("/aps/2/resources/" + hpr.aps_id, None, None, hpr.PATH_CERTIFICATE)

    constructor = get_constructor(old_json)
    properties = get_properties(hpr.schema)

    old_resource = constructor()
    for prop in properties:
        setattr(old_resource, prop, old_json[prop])
    logger.info("OLD = " + old_resource.apphost)
    logger.info("OLD = " + old_resource.cloudadmin)
    logger.info("OLD = " + old_resource.cloudpass)
   
    result = aps2.call_to_application.call_unprovision(old_resource)

    return result


# see post
def call_method_get():
    # aps_id = hpr.REQUEST_URI[len(hpr.SCRIPT_NAME)+1:]
    # aps_id = aps_id[aps_id.find('/')+1:]
 
    old_json = hpr.APS_API.GET("/aps/2/resources/" + hpr.aps_id, None, None, hpr.PATH_CERTIFICATE)

    constructor = get_constructor(old_json)
    properties = get_properties(hpr.schema)

    old_resource = constructor()
    for prop in properties:
        setattr(old_resource, prop, old_json[prop])
    logger.info("OLD = " + old_resource.apphost)
    logger.info("OLD = " + old_resource.cloudadmin)
    logger.info("OLD = " + old_resource.cloudpass)
   
    result = aps2.call_to_application.call_retrieve(old_resource, properties, old_json)

    return result


# see post
def call_method_put():
    request_size = get_request_length(hpr.environ)
    request_body = hpr.environ['wsgi.input'].read(request_size)
    # request_json = json.loads(request_body, object_hook=lambda x: aps2.apsapi.JsonNode(**x))
    request_json = json.loads(request_body, object_hook=Struct)
    
    # print_request_body(request_body)

    old_json = hpr.APS_API.GET("/aps/2/resources/" + hpr.aps_id, None, None, hpr.PATH_CERTIFICATE)

    constructor = get_constructor(old_json)
    properties = get_properties(hpr.schema)

    old_resource = constructor()
    for prop in properties:
        setattr(old_resource, prop, old_json[prop])
    logger.info("OLD = " + old_resource.apphost)
    logger.info("OLD = " + old_resource.cloudadmin)
    logger.info("OLD = " + old_resource.cloudpass)
   
    new_resource = constructor()
    for prop in properties:
        setattr(new_resource, prop, request_json[prop])
    logger.info("NEW = " + new_resource.apphost)
    logger.info("NEW = " + new_resource.cloudpass)
    logger.info("NEW = " + new_resource.cloudadmin)
        
    result = aps2.call_to_application.call_configure(old_resource, new_resource, properties, request_json)

    return result


def print_environment(environ):
    logger.info('REQUEST ENVIRONMENT:')
    logger.info(pprint.pformat(environ))


def print_request_body(request_body):
    logger.info("REQUEST BODY:") 
    logger.info(request_body)


def print_list_services(list_services):
    logger.info("LIST_SERVICES:")
    logger.info(list_services)


def get_aps_id():
    len_service_id = len('/' + hpr.service_id.main_name + '/')
    if len_service_id > len(hpr.PATH_INFO):
        # logger.info("length /service_id/ > len(hpr.PATH_INFO)")
        # logger.info("=> PATH_INFO not consist aps_id")
        return None
    string_without_service_id = hpr.PATH_INFO[len_service_id:]
    # logger.info("string_without_service_id = " + string_without_service_id)
    pattern = re.compile('[\w-]{36}')
    if pattern.match(string_without_service_id):
        aps_id = string_without_service_id[:36]
        # logger.info("aps_id = " + aps_id)
        return aps_id

    return None


def get_func():
    # logger.info("PATH_INFO = " + hpr.PATH_INFO)
    # logger.info("service_id = " + hpr.service_id.main_name)
    if hpr.aps_id:
        # logger.info("aps_id set :)")
        # logger.info("aps_id = " + hpr.aps_id)
        len_service_id_aps_id = len('/' + hpr.service_id.main_name + '/' + hpr.aps_id)
        # logger.info("len_service_id_aps_id = %d " % len_service_id_aps_id)
        func = hpr.PATH_INFO[len_service_id_aps_id:]
    else:
        # logger.info("aps_id not set")
        len_service_id = len('/' + hpr.service_id.main_name + '/')
        # logger.info("len_service_id = %d " % len_service_id)
        func = hpr.PATH_INFO[len_service_id:]
    return func


def get_list_valid_patterns():
    for oper in hpr.schema.operations:
        logger.info("oper = " + oper)

    #     # logger.info(oper)
    #     path = hpr.schema['operations'][oper]['path']
    #     logger.info("path = " + path)
    #     if path.find('{') != -1:
    #         without_params = path[:path.find('{')]
    #     else:
    #         without_params = path
    #     logger.info("without_params = " + without_params)
    #     valid_pattern = re.compile(without_params + '\w*')  # TODO type = 'string'
    #     if valid_pattern.match(hpr.func):
    #         old_json = hpr.APS_API.GET("/aps/2/resources/" + hpr.aps_id, None, None, hpr.PATH_CERTIFICATE)
    #         result = ''
    #         constructor = get_constructor(hpr.schema, old_json)
    #
    #         properties = get_properties(hpr.schema)
    #         old_resource = constructor()
    #         for prop in properties:
    #             setattr(old_resource, prop, old_json[prop])
    #         logger.info("call_func : OLD = " + old_resource.apphost)
    #         logger.info("call_func : OLD = " + old_resource.cloudadmin)
    #         logger.info("call_func : OLD = " + old_resource.cloudpass)
    #
    #         result = aps2.call_to_application.call_custom_function(old_resource, oper)
    #
    #         logger.info("ok")
    #         return result
    #
    #     else:
    #         logger.info("not")


def call_custom_func():
    logger.info("schema: ")
    logger.info(hpr.schema)
    logger.info("PATH_INFO = + " + hpr.PATH_INFO)
    logger.info("func = " + hpr.func)
    list_valid_patterns = get_list_valid_patterns()
    # for oper in schema['operations']:
    #     logger.info("oper = " + oper)
    #     # logger.info(oper)
    #     path = schema['operations'][oper]['path']
    #     logger.info("path = " + path)
    #     if path.find('{') != -1:
    #         without_params = path[:path.find('{')]
    #     else:
    #         without_params = path
    #     logger.info("without_params = " + without_params)
    #     valid_pattern = re.compile(without_params + '\w*')  # TODO type = 'string'
    #     if valid_pattern.match(hpr.func):
    #         old_json = hpr.APS_API.GET("/aps/2/resources/" + hpr.aps_id, None, None, hpr.PATH_CERTIFICATE)
    #         result = ''
    #         constructor = get_constructor(schema, old_json)
    #
    #         properties = get_properties(schema)
    #         old_resource = constructor()
    #         for prop in properties:
    #             setattr(old_resource, prop, old_json[prop])
    #         logger.info("call_func : OLD = " + old_resource.apphost)
    #         logger.info("call_func : OLD = " + old_resource.cloudadmin)
    #         logger.info("call_func : OLD = " + old_resource.cloudpass)
    #
    #         result = aps2.call_to_application.call_custom_function(old_resource, oper)
    #
    #         logger.info("ok")
    #         return result
    #
    #     else:
    #         logger.info("not")

    # raise Exception("Name function not valid")


# 'application' is main function
# environ is all info. You can see info with:
#    logger.info('REQUEST ENVIRONMENT:')
#    logger.info(pprint.pformat(environ))
# 
# 'start_response' for response (ex. 500 Error, 204 Ok, 200 Ok)
def application(environ, start_response):

    try:
        global logger
        logger = aps2.uLogging.get_logger('/tmp/myapp.log', aps2.uLogging.DEBUG)

        logger.info("----------------------------------------------------")

        result = ''
        print_environment(environ)

        global hpr
        hpr = aps2.helper.Helper()
        hpr.put_environ(environ)

        hpr.service_id = get_service_id()
        hpr.aps_id = get_aps_id()
        hpr.func = get_func()
        hpr.schema = get_schema()

        if not hpr.func:
            logger.info("it is NOT custom function")
            if hpr.REQUEST_METHOD == 'POST':
                result = call_method_post()
            elif hpr.REQUEST_METHOD == 'DELETE':
                result = call_method_delete()
            elif hpr.REQUEST_METHOD == 'GET':
                result = call_method_get()
            elif hpr.REQUEST_METHOD == 'PUT':
                result = call_method_put()

            if hpr.REQUEST_METHOD == "DELETE":
                start_response('204 OK', [('Content-type', 'text/plain')])
            else:
                start_response('200 OK', [('Content-type', 'text/plain')])
        else:
            logger.info("it is custom function")
            logger.info("func = " + hpr.func)
            call_custom_func()

        logger.info("----------------------------------------------------")
        return [result]
    except Exception as e:
        logger.info("Error: " + str(e))
        start_response('500 Internal Error', [('Content-type', 'text/plain')])
        return ["Error: "+str(e)]
