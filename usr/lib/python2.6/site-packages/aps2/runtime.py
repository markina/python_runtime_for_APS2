import pprint
import os
import re

import simplejson as json
import ordereddict

import xml.etree.ElementTree as ET

import aps2.apsapi
import aps2.aps
import aps2.call_to_application
import aps2.helper

import aps2.uLogging

from apsapi import logger  # TODO

os.environ['APP_PATH'] = '/usr/local/share/applications/pycloud/'

NF_APP_META = 'APP-META.xml'
NF_LIST_SERVICES = 'list_services.json'
STRING = 'string'


def get_request_length(environ):
    try:
        request_body_size = int(environ.get('CONTENT_LENGTH', 0))
    except ValueError:
        request_body_size = 0
    return request_body_size


# save_certificate call from call_method_post
# Save certificate from request_json for using PUT GET DELETE
def save_certificate(request_json):
    self = request_json["aps"]["x509"]["self"]
    controller = request_json["aps"]["x509"]["controller"]

    try:
        dir_config = os.environ['APP_PATH'] + 'config/'
        if not os.path.exists(dir_config):
            os.makedirs(dir_config)
        with open(os.environ['APP_PATH'] + 'config/' + hpr.HTTP_APS_INSTANCE_ID + '.pem', 'w') as outfile:
            outfile.write(self)
        with open(os.environ['APP_PATH'] + 'config/' + hpr.HTTP_APS_INSTANCE_ID + '.apsc.pem', 'w') as outfile:
            outfile.write(controller)
    except OSError:
        raise Exception("Cannot make directory 'config/'")
    except IOError:
        raise Exception("Certificate cannot open")


def get_appmeta(json_data):
    if os.path.isfile(os.environ['APP_PATH'] + NF_APP_META):
        tree_appmeta = ET.parse(os.environ['APP_PATH'] + NF_APP_META)
    else:
        uri_appmeta = json_data.aps.package.href + '/APP-META.xml'
        tree_appmeta = hpr.APS_API.GET(uri_appmeta, None, None, hpr.PATH_CERTIFICATE, False)
        # this 'write' write tree_appmeta with prefix = 'ns0'
        tree_appmeta.write(os.environ['APP_PATH'] + NF_APP_META)
    return tree_appmeta.getroot()


def get_constructor(json_data):
    class_name = hpr.schema["name"]
   
    tree_appmeta = get_appmeta(json_data)

    appmeta_namespace = re.search('\{(.*)\}', tree_appmeta.tag).group(1)
    services = tree_appmeta.findall(".//{" + appmeta_namespace + "}service")

    service_id = hpr.service_id

    script_path = ""
    for service in services:
        if service.get('id') == service_id.main_name:
            script_path = service.findall(".//{" + appmeta_namespace + "}code")[0].get('path')  # TODO
            script_path = script_path[script_path.find('/')+1:script_path.rfind('.')]
            break

    # logger.info("class_name = " + class_name)
    # logger.info('script_path = ' + script_path)

    import_script = __import__(script_path)
    constructor = getattr(import_script, class_name)       
    
    return constructor


# def get_service_id():
#     list_services = hpr.application_services
#
#     # print_list_services(list_services)
#
#     service_id = None
#     for item in list_services:
#         logger.info("item = " + item)
#         pattern = re.compile('/' + item)
#         if pattern.match(hpr.PATH_INFO):
#             service_id = list_services[item]
#             service_id.main_name = item
#             break
#
#     # logger.info("list_services: aps_id = " + list_services.aps.id)
#     if service_id is None:
#         raise Exception("Error: service_id in PATH_INFO not exist!")
#     return service_id


# call_method_post work post request:
#
# 1. Get request_json (info about host_name, admin_name ... , aps.type, aps.package.href
# You can see request_json with :
#   if request_size:        if

#       logger.info('REQUEST BODY:')
#       logger.info(request_body)
# 2. Save certificate
# 3. Get schema for info about scripts (ex. class_name, properties define in scripts)
# see. clouds.schema.gen 
# 5. Create new_resource and fill properties from arrived json (request_json)
# 6. Send new_resource with properties call_provision
# 7. Return new json with properties after provision()   
def call_method_post():
    request_body = hpr.body
    request_json = hpr.body_json

    print_environment(hpr.environ)
    print_request_body(request_body)
    save_certificate(request_json)

    # logger.info("schema = ")
    # logger.info(schema)
    # logger.info("schema.name = " + schema.name)

    constructor = get_constructor(request_json)
    properties = get_properties(hpr.schema)

    new_resource = constructor()
    for prop in properties:
        setattr(new_resource, prop, request_json[prop])

    logger.info("NEW = " + new_resource.apphost)
    logger.info("NEW = " + new_resource.cloudpass)
    logger.info("NEW = " + new_resource.cloudadmin)
        
    result = aps2.call_to_application.call_provision(new_resource, properties, request_json)
    return result


def get_properties(schema):
    properties = []
    json_properties = schema["properties"]
    for prop in json_properties.items():
        # logger.info("1 = " + str(prop[0]))
        properties.append(str(prop[0]))
    return properties


# call_method_delete post request:
#
# 1. Get old_json   
# 3. Get schema for info about scripts (ex. class_name, properties define in scripts)
# see. clouds.schema.gen 
# 5. Create old_resource and fill properties from arrived json (old_json)
# 6. Send old_resource with properties call_unprovision
# 7. Return new json with properties after unprovision()   
def call_method_delete():
    logger.info("aps_id = " + hpr.aps_id)
    old_json = hpr.APS_API.GET("/aps/2/resources/" + hpr.aps_id, None, None, hpr.PATH_CERTIFICATE)

    constructor = get_constructor(old_json)
    properties = get_properties(hpr.schema)

    old_resource = constructor()
    for prop in properties:
        setattr(old_resource, prop, old_json[prop])
    logger.info("OLD = " + old_resource.apphost)
    logger.info("OLD = " + old_resource.cloudadmin)
    logger.info("OLD = " + old_resource.cloudpass)
   
    result = aps2.call_to_application.call_unprovision(old_resource)

    return result


# see post
def call_method_get():
    old_json = hpr.APS_API.GET("/aps/2/resources/" + hpr.aps_id, None, None, hpr.PATH_CERTIFICATE)

    constructor = get_constructor(old_json)
    properties = get_properties(hpr.schema)

    old_resource = constructor()
    for prop in properties:
        setattr(old_resource, prop, old_json[prop])
    logger.info("OLD = " + old_resource.apphost)
    logger.info("OLD = " + old_resource.cloudadmin)
    logger.info("OLD = " + old_resource.cloudpass)
   
    result = aps2.call_to_application.call_retrieve(old_resource, properties, old_json)

    return result


# see post
def call_method_put():
    request_body = hpr.body
    request_json = hpr.body_json
    
    # print_request_body(request_body)

    old_json = hpr.APS_API.GET("/aps/2/resources/" + hpr.aps_id, None, None, hpr.PATH_CERTIFICATE)

    constructor = get_constructor(old_json)
    properties = get_properties(hpr.schema)

    old_resource = constructor()
    for prop in properties:
        setattr(old_resource, prop, old_json[prop])
    logger.info("OLD = " + old_resource.apphost)
    logger.info("OLD = " + old_resource.cloudadmin)
    logger.info("OLD = " + old_resource.cloudpass)
   
    new_resource = constructor()
    for prop in properties:
        setattr(new_resource, prop, request_json[prop])
    logger.info("NEW = " + new_resource.apphost)
    logger.info("NEW = " + new_resource.cloudpass)
    logger.info("NEW = " + new_resource.cloudadmin)
        
    result = aps2.call_to_application.call_configure(old_resource, new_resource, properties, request_json)

    return result


def print_environment(environ):
    logger.info('REQUEST ENVIRONMENT:')
    logger.info(pprint.pformat(environ))


def print_request_body(request_body):
    logger.info("REQUEST BODY:") 
    logger.info(request_body)


def print_list_services(list_services):
    logger.info("LIST_SERVICES:")
    logger.info(list_services)


class Parameter:
    def __init__(self, name_parameter=None, value_parameter=None):
        self.name = name_parameter
        self.value = value_parameter


class CustomFunction:
    def __init__(self):
        self.json = None
        self.call_name = None
        self.list_params = []
        self.pattern = None
        self.params_values = {}


def get_list_valid_custom_functions():
    list_custom_functions = []
    for oper in hpr.schema["operations"]:
        path = hpr.schema["operations"][oper]["path"]
        if path.find('{') != -1:
            without_params = path[:path.find('{')-1]
        else:
            without_params = path
        string_parameters = path[len(without_params)+1:]
        pattern_string = without_params
        function = CustomFunction()
        for parameter in re.split("/", string_parameters):
            parameter = parameter[1:len(parameter)-1]
            # logger.info("parameter = " + parameter)
            # TODO assert valid parameter
            type = hpr.schema["operations"][oper]["parameters"][parameter]["type"]
            # logger.info("type = " + type)
            function.list_params.append(Parameter(parameter))
            if type == STRING:
                pattern_string += "/(?P<" + parameter + ">[a-zA-Z][0-9a-zA-Z_]*)"
        logger.info("pattern_string = " + pattern_string)
        function.pattern = re.compile(pattern_string)
        function.json = hpr.schema["operations"][oper]
        function.call_name = str(oper)
        list_custom_functions.append(function)
    return list_custom_functions


def add_parameters_from_query_string(function):
    logger.info("QUERY_STRING = " + hpr.QUERY_STRING)
    if not hpr.QUERY_STRING:
        return
    for parameter in hpr.QUERY_STRING.split("&"):
        assert parameter.count('=') == 1, "Parameter in QUERY_STRING not valid"
        name = parameter.split("=")[0]
        value = parameter.split("=")[1]
        # logger.info("name = " + name)
        # logger.info("value = " + value)
        function.list_params.append(Parameter(name, value))


def call_custom_func():
    logger.info("schema: ")
    logger.info(json.dumps(hpr.schema, indent=8))
    # logger.info("PATH_INFO = + " + hpr.PATH_INFO)
    # logger.info("func = " + hpr.func)
    list_valid_custom_functions = get_list_valid_custom_functions()
    # arguments = []
    for function in list_valid_custom_functions:
        # logger.info("pat = " + str(function.pattern))
        result_re = function.pattern.match(hpr.func)
        if result_re:  # TODO add checks: verb and other
            current_custom_function = function
            break
    else:
        raise Exception("Not found custom function")

    for parameter in current_custom_function.list_params:
        string_parameter = result_re.group(parameter.name)
        logger.info(parameter.name + " = " + string_parameter)
        parameter.value = string_parameter
    # logger.info("json = " + str(function.json))
    # logger.info("call_name = " + function.call_name)
    add_parameters_from_query_string(current_custom_function)

    # ###
    # logger.info("check!!")
    # for par in current_custom_function.list_params:
    #     logger.info("par = " + par.name)
    #     logger.info("par = " + par.value)
    # ###

    old_json = hpr.APS_API.GET("/aps/2/resources/" + hpr.aps_id,
                               None, None, hpr.PATH_CERTIFICATE)
    constructor = get_constructor(old_json)

    properties = get_properties(hpr.schema)
    old_resource = constructor()
    for prop in properties:
        setattr(old_resource, prop, old_json[prop])
    # logger.info("call_custom_func : OLD = " + old_resource.apphost)
    # logger.info("call_custom_func : OLD = " + old_resource.cloudadmin)
    # logger.info("call_custom_func : OLD = " + old_resource.cloudpass)

    result = aps2.call_to_application.call_custom_function(old_resource, current_custom_function, hpr)

    logger.info(result)

    return result


# 'application' is main function
# environ is all info. You can see info with:
#    logger.info('REQUEST ENVIRONMENT:')
#    logger.info(pprint.pformat(environ))
# 
# 'start_response' for response (ex. 500 Error, 204 Ok, 200 Ok)
def application(environ, start_response):

    try:
        global logger
        logger = aps2.uLogging.get_logger('/tmp/myapp.log', aps2.uLogging.DEBUG)

        logger.info("----------------------------------------------------")

        result = ''
        # print_environment(environ)

        global hpr
        hpr = aps2.helper.Helper()
        hpr.put_environ(environ)


        #
        # logger.info("body_json:")
        # logger.info(hpr.body_json)

        if not hpr.func:
            logger.info("it is NOT custom function")
            if hpr.REQUEST_METHOD == 'POST':
                result = call_method_post()
            elif hpr.REQUEST_METHOD == 'DELETE':
                result = call_method_delete()
            elif hpr.REQUEST_METHOD == 'GET':
                result = call_method_get()
            elif hpr.REQUEST_METHOD == 'PUT':
                result = call_method_put()
        else:
            logger.info("it is custom function")
            logger.info("func = " + hpr.func)
            result = call_custom_func()

        if hpr.REQUEST_METHOD == "DELETE":
            start_response('204 OK', [('Content-type', 'text/plain')])
        else:
            start_response('200 OK', [('Content-type', 'text/plain')])

        logger.info("----------------------------------------------------")
        return [result]
    except Exception as e:
        logger.info("Error: " + str(e))
        start_response('500 Internal Error', [('Content-type', 'text/plain')])
        return ["Error: " + str(e)]
