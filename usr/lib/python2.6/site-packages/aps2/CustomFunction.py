import aps2.Parameter
import aps2.printer

import simplejson as json
import ordereddict
import re
import urlparse

logger = aps2.uLogging.get_logger('/tmp/myapp.log', aps2.uLogging.DEBUG)
PATH = "path"
QUERY = "query"
BODY = "body"


class ValidCustomFunction:
    def __init__(self, main_name, pattern, verb):
        self.main_name = main_name
        self.pattern = pattern
        self.verb = verb


def get_valid_custom_functions(schema):
    list_valid_custom_functions = []
    for oper in schema["operations"]:
        path = schema["operations"][oper]["path"]
        if path.find('{') != -1:
            name_in_path = path[:path.find('{')-1]         # name_in_path = "/calculateSomething"
        else:
            name_in_path = path
        params_in_path = path[len(name_in_path)+1:]       # params_in_path = "{pathparam}/{ps}"
        re_valid_pattern = name_in_path
        for param_i in re.split("/", params_in_path):
            param_i = param_i[1:len(param_i)-1]
            re_valid_pattern += "/(?P<" + param_i + ">[a-zA-Z][0-9a-zA-Z_]*)"
        # logger.info("re_valid_pattern = " + re_valid_pattern)
        valid_custom_func = ValidCustomFunction(oper, re.compile(re_valid_pattern), schema["operations"][oper]["verb"])
        list_valid_custom_functions.append(valid_custom_func)
    return list_valid_custom_functions


def is_match_for_custom_function(valid_custom_function, cur_func):
    result_re = valid_custom_function.pattern.match(cur_func)
    if not result_re:
        return False
    if valid_custom_function.verb != aps2.Info.Info.get_REQUEST_METHOD():
        return False
    return True


def get_valid_custom_function(cur_func, schema):
    valid_custom_functions = get_valid_custom_functions(schema)
    for valid_custom_function in valid_custom_functions:
        if is_match_for_custom_function(valid_custom_function, cur_func):
            return valid_custom_function
    else:
        raise Exception("Not found custom valid_custom_function")


class CustomFunction:
    """
    main_name: for ex: createKeyFunc
    pattern: for ex: re.compile("/createKey/(?P<paramX>[a-zA-Z][0-9a-zA-Z_]*)
    json:
        "verb": "POST",
        "path": "/createKey/{pathparam}/{ps}",
        "response": {...},
        "access": {...},
        "parameters": {...}
    parameters: [Parameter()]
    """

    def __init__(self):
        valid_custom_function = get_valid_custom_function(
            aps2.InfoParse.InfoParse.get_current_function(),
            aps2.ServiceId.ServiceId.get_schema_json()
        )
        self.main_name = valid_custom_function.main_name
        self.pattern = valid_custom_function.pattern
        self.json = aps2.ServiceId.ServiceId.get_schema_json()["operations"][self.main_name]
        self.parameters = self.get_parameters()

    def get_parameters(self):
        list_parameters = []
        for param in self.json["parameters"]:
            kind_param = self.json["parameters"][param]["kind"]
            if kind_param == PATH:
                value = self.pattern.match(aps2.InfoParse.InfoParse.get_current_function()).group(param)
            elif kind_param == QUERY:
                query_dict = dict(urlparse.parse_qsl(aps2.Info.Info.get_QUERY_STRING()))
                value = query_dict[param]
            elif kind_param == BODY:
                value = json.dumps(aps2.Info.Info.get_BODY_JSON())
            else:
                raise Exception("Unknown kind of parameter: " + kind_param)
            list_parameters.append(aps2.Parameter.Parameter(param, value, self.json["parameters"][param]))

        return list_parameters
