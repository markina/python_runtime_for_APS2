# import aps2.parameter
import aps2.printer

import json
import re

logger = aps2.uLogging.get_logger('/tmp/myapp.log', aps2.uLogging.DEBUG)


class ValidCustomFunction:
    def __init__(self, main_name, pattern, verb):
        self.main_name = main_name
        self.pattern = pattern
        self.verb = verb


def get_valid_custom_functions(schema):
    list_valid_custom_functions = []
    for oper in schema["operations"]:
        path = schema["operations"][oper]["path"]
        if path.find('{') != -1:
            name_in_path = path[:path.find('{')-1]         # name_in_path = "/calculateSomething"
        else:
            name_in_path = path
        params_in_path = path[len(name_in_path)+1:]       # params_in_path = "{pathparam}/{ps}"
        re_valid_pattern = name_in_path
        for param_i in re.split("/", params_in_path):
            param_i = param_i[1:len(param_i)-1]
            re_valid_pattern += "/(?P<" + param_i + ">[a-zA-Z][0-9a-zA-Z_]*)"
        # logger.info("re_valid_pattern = " + re_valid_pattern)
        valid_custom_func = ValidCustomFunction(oper, re.compile(re_valid_pattern), schema["operations"][oper]["verb"])
        list_valid_custom_functions.append(valid_custom_func)
    return list_valid_custom_functions


def is_match_for_custom_function(valid_custom_function, cur_func):
    result_re = valid_custom_function.pattern.match(cur_func)
    if not result_re:
        return False
    if valid_custom_function.verb != aps2.Info.Info.get_REQUEST_METHOD():
        return False
    return True


def get_valid_custom_function(cur_func, schema):
    # aps2.printer.print_json("schema:", schema)
    # logger.info("PATH_INFO = + " + aps2.Info.Info.get_PATH_INFO())
    # logger.info("cur_func = " + cur_func)
    valid_custom_functions = get_valid_custom_functions(schema)
    for valid_custom_function in valid_custom_functions:
        if is_match_for_custom_function(valid_custom_function, cur_func):
            return valid_custom_function
    else:
        raise Exception("Not found custom valid_custom_function")


class CustomFunction:
    # For example:
    # pattern = re.compile("/createKey/(?P<pathparam>[a-zA-Z][0-9a-zA-Z_]*)/(?P<ps>[a-zA-Z][0-9a-zA-Z_]*)")
    # main_name = createKeyFunc
    # json =
    # #### "createKeyFunc": {
    #         "verb": "POST",
    #         "path": "/createKey/{pathparam}/{ps}",
    #         "response": {
    #                 "contentType": null,
    #                 "type": "http://user-mgmt.demo.apsdemo.org/methods/vpses/1.0#OS",
    #                 "items": null
    #         },
    #         "access": {
    #                 "referrer": true
    #         },
    #         "parameters": {
    #                 "pathparam": {
    #                         "type": "string",
    #                         "required": true,
    #                         "kind": "path"
    #                 }
    #         }
    # ### }
    # parameters = Parameter()[]
    def __init__(self):
        valid_custom_function = get_valid_custom_function(
            aps2.InfoParse.InfoParse.get_current_function(),
            aps2.ServiceId.ServiceId.get_schema_json()
        )
        self.main_name = valid_custom_function.main_name
        self.pattern = valid_custom_function.pattern
        self.json = aps2.ServiceId.ServiceId.get_schema_json()["operations"][self.main_name]
        self.parameters = self.get_parameters()

        # self.fill_information()


    def get_parameters(self):
        for param in self.json["parameters"]:
            logger.info("param name = " + param)
            kind_param = self.json["parameters"][param]["kind"]
            logger.info("kind_param = " + kind_param)


        return None

    # def fill_information(self):
    #     custom_function = self.get_appropriate_custom_function()
    #     logger.info("custom_function.main_name = " + custom_function.main_name)
    #     logger.info("custom_function.pattern = " + str(custom_function.pattern))
    #     logger.info("custom_function.json = " + json.dumps(custom_function.json, indent=8))
    #
    #     for param in custom_function.get_parameters():
    #         logger.info("param.name = " + param.name)
    #         aps2.printer.print_json("param.json = ", param.json)
    #
    # def get_parameters(self):
    #     aps2.printer.print_json("PARAMETERS:", self.json["parameters"])
    #     for name_param in self.json["parameters"]:
    #         aps2.printer.print_json("name param = ", name_param)
    #         parameter = aps2.parameter.Parameter(name_param)
    #         parameter.json = self.json["parameters"][name_param]
    #         self.parameters.append(parameter)
    #     return self.parameters
    #
    # def get_appropriate_custom_function(self):
    #     # logger.info("schema: ")
    #     # logger.info(json.dumps(hpr.schema_json, indent=8))
    #     # logger.info("PATH_INFO = + " + hpr.PATH_INFO)
    #     # logger.info("func = " + hpr.current_function)
    #     valid_custom_functions = self.get_valid_custom_functions()
    #     for valid_custom_function in valid_custom_functions:
    #         # logger.info("pat = " + str(valid_custom_function.pattern))
    #         if self.is_match_for_custom_function(valid_custom_function):
    #             logger.info("is Match!")
    #             return valid_custom_function
    #     else:
    #         logger.info("is not Match!!")
    #         raise Exception("Not found custom valid_custom_function")
    #
    # def get_valid_custom_functions(self):
    #     list_custom_functions = []
    #     for oper in aps2.ServiceId.ServiceId.get_schema_json(self.hpr)["operations"]:
    #         path = aps2.ServiceId.ServiceId.get_schema_json(self.hpr)["operations"][oper]["path"]
    #         if path.find('{') != -1:
    #             beginning_of_the_path = path[:path.find('{')-1]         # beginning_of_the_path = "/calculateSomething"
    #         else:
    #             beginning_of_the_path = path
    #         logger.info("beginning_of_the_path = " + beginning_of_the_path)
    #         end_of_the_path = path[len(beginning_of_the_path)+1:]       # end_of_the_path = "{pathparam}/{ps}"
    #         logger.info("end_of_the_path = " + end_of_the_path)
    #         pattern_string = beginning_of_the_path
    #         logger.info("pattern_string = " + pattern_string)
    #         # function = aps2.custom_function.CustomFunction(self.hpr)
    #         for parameter in re.split("/", end_of_the_path):
    #             parameter = parameter[1:len(parameter)-1]
    #             # logger.info("parameter = " + parameter)
    #             # TODO assert valid parameter
    #             # type_param = hpr.schema_json["operations"][oper]["parameters"][parameter]["type"]
    #             # logger.info("type_param = " + type_param)
    #             # function.list_params.append(Parameter(parameter))
    #             pattern_string += "/(?P<" + parameter + ">[a-zA-Z][0-9a-zA-Z_]*)"
    #         self.pattern = re.compile(pattern_string)
    #         self.json = aps2.ServiceId.ServiceId.get_schema_json(self.hpr)["operations"][oper]
    #         self.main_name = str(oper)
    #         logger.info("pattern_string = " + pattern_string)
    #         logger.info("function.json = ...")
    #         logger.info("function.main_name = " + self.main_name)
    #         list_custom_functions.append(self)
    #     return list_custom_functions
    #
    # def add_parameters_from_query_string(self, function):
    #     logger.info("QUERY_STRING = " + self.hpr.QUERY_STRING)
    #     if not self.hpr.QUERY_STRING:
    #         return
    #     for parameter in self.hpr.QUERY_STRING.split("&"):
    #         assert parameter.count('=') == 1, "Parameter in QUERY_STRING not valid"
    #         name = parameter.split("=")[0]
    #         value = parameter.split("=")[1]
    #         # logger.info("name = " + name)
    #         # logger.info("value = " + value)
    #         function.list_params.append(aps2.parameter.Parameter(name, value))
    #
    # def is_match_for_custom_function(self, valid_custom_function):
    #     result_re = valid_custom_function.pattern.match(self.hpr.current_function)
    #     if not result_re:
    #         return False
    #     logger.info("valid_custom_function.json.verb = " + valid_custom_function.json["verb"])
    #     if valid_custom_function.json["verb"] != self.hpr.REQUEST_METHOD:
    #         return False
    #     # TODO add checks: verb and other
    #     return True
    #

