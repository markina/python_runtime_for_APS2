import aps2.Parameter
import aps2.printer
import aps2.uLogging

import simplejson as json
import ordereddict
import re
import urlparse

PATH = "path"
QUERY = "query"
BODY = "body"


class ValidCustomFunction:
    def __init__(self, main_name, pattern, jsn):
        self.main_name = main_name
        self.pattern = pattern
        self.jsn = jsn


def get_pattern_by_path(path):
    if path.find('{') != -1:
        name_in_path = path[:path.find('{')-1]         # name_in_path = "/calculateSomething"
        params_in_path = path[len(name_in_path)+1:]       # params_in_path = "{pathparam}/{ps}"
        re_valid_pattern = name_in_path
        for param_i in re.split("/", params_in_path):
            param_i = param_i[1:len(param_i)-1]
            re_valid_pattern += "/(?P<" + param_i + ">[0-9a-zA-Z_]*)"  # TODO fix [a-zA-Z][0-9a-zA-Z_]*
    else:
        re_valid_pattern = path

    return re.compile(re_valid_pattern)


def get_valid_custom_function(schema):
    for oper in schema.get("operations", []):
        path = schema["operations"][oper]["path"]
        re_valid_pattern = get_pattern_by_path(path)

        json = schema["operations"][oper]
        if is_match_for_custom_function(re_valid_pattern, json):
            return ValidCustomFunction(oper, re_valid_pattern, json)

    for impl in schema.get("implements", []):
        other_schema = aps2.InfoParse.InfoParse.get_aps_api().GET(
            "/aps/2/types/?id=" + impl,
            None,
            None,
            aps2.InfoParse.InfoParse.get_pem_path_certificate()
        )[0]
        result = get_valid_custom_function(other_schema)
        if result:
            return result


def is_match_for_custom_function(pattern, jsn):
    result_re = pattern.match(aps2.InfoParse.InfoParse.get_current_function())
    if not result_re:
        return False
    if jsn["verb"] != aps2.Info.Info.get_REQUEST_METHOD():
        return False
    return True


class CustomFunction:
    """
    main_name: for ex: createKeyFunc
    pattern: for ex: re.compile("/createKey/(?P<paramX>[a-zA-Z][0-9a-zA-Z_]*)
    json:
        "verb": "POST",
        "path": "/createKey/{pathparam}/{ps}",
        "response": {...},
        "access": {...},
        "parameters": {...}
    parameters: [Parameter()]
    """

    def __init__(self):
        valid_custom_function = get_valid_custom_function(
            aps2.ServiceId.ServiceId.get_schema_json()
        )
        assert valid_custom_function, "Not found custom valid_custom_function"
        self.main_name = valid_custom_function.main_name
        self.pattern = valid_custom_function.pattern
        self.json = valid_custom_function.jsn

        aps2.uLogging.debug("customFunction.main_name = " + self.main_name)
        aps2.printer.print_json("customFunction.json = ", self.json)

        self.parameters = self.get_parameters()

    def get_parameters(self):
        list_parameters = []
        for param in self.json.get("parameters", []):
            kind_param = self.json["parameters"][param]["kind"]
            if kind_param == PATH:
                value = self.pattern.match(aps2.InfoParse.InfoParse.get_current_function()).group(param)
            elif kind_param == QUERY:
                query_dict = dict(urlparse.parse_qsl(aps2.Info.Info.get_QUERY_STRING()))
                value = query_dict[param]
            elif kind_param == BODY:
                value = aps2.Info.Info.get_BODY_JSON()
            else:
                raise Exception("Unknown kind of parameter: " + kind_param)
            list_parameters.append(aps2.Parameter.Parameter(param, value, self.json["parameters"][param]))

        return list_parameters
