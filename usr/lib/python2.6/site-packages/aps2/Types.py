import os
import simplejson as json
import ordereddict
import xml.etree.ElementTree as ET

import aps2.apsapi
import aps2.uLogging
import aps2.Info

NAME_FILE_LIST_SERVICES = 'list_services.json'
NAME_FILE_APP_META = 'APP-META.xml'


class Types:
    __application_services_json = None
    __appmeta_et_root = None

    @staticmethod
    def get_application_services_json():
        """
        Return json from cache NAME_FILE_LIST_SERVICES or from controller with call aps2.apsapi.API.APS_API.GET()
        It's stored information about services. For example:
        "aps": {
                "endpoint": "https://endpoint.a.apscloudstest.apsdemo.org:443/endpoint000/",
                "id": "022183f5-0945-4465-952b-95ef4e92ac8b",
                "type": "http://aps-standard.org/samples/starter"
        },
        "clouds": {
                "name": "VPS cloud globals",
                "schema": "/aps/2/types/90",
                "summary": "VPS cloud application global service",
                "type": "http://aps-standard.org/samples/starter/cloud/1.0"
        },
        "contexts": {
                "name": "VPS Management",
                "schema": "/aps/2/types/91",
                "summary": "VPS management environment",
                "type": "http://aps-standard.org/samples/starter/context/1.0"
        }
        """
        if Types.__application_services_json:
            return Types.__application_services_json

        if os.path.isfile(os.environ['APP_PATH'] + NAME_FILE_LIST_SERVICES):
            with open(os.environ['APP_PATH'] + NAME_FILE_LIST_SERVICES) as inFile:
                application_services = json.loads(inFile.read(), object_pairs_hook=ordereddict.OrderedDict)
        else:
            application_services = aps2.InfoParse.InfoParse.get_APS_API().GET(
                '/aps/2/application', None, None, aps2.InfoParse.InfoParse.get_apsc_pem_path_certificate()
            )
            with open(os.environ['APP_PATH'] + NAME_FILE_LIST_SERVICES, 'wb') as outfile:
                outfile.write(json.dumps(application_services, indent=8))
        Types.__application_services_json = application_services
        return application_services

    @staticmethod
    def save_certificate():
        """
        The certificate is stored in the call POST
        It used when a standard call
        """
        aps_self = aps2.Info.Info.get_BODY_JSON()["aps"]["x509"]["self"]
        aps_controller = aps2.Info.Info.get_BODY_JSON()["aps"]["x509"]["controller"]
        try:
            dir_config = os.environ['APP_PATH'] + 'config/'
            if not os.path.exists(dir_config):
                os.makedirs(dir_config)
            with open(aps2.InfoParse.InfoParse.get_pem_path_certificate(), 'w') as outfile:
                outfile.write(aps_self)
            with open(aps2.InfoParse.InfoParse.get_apsc_pem_path_certificate(), 'w') as outfile:
                outfile.write(aps_controller)
        except OSError:
            raise Exception("Cannot make directory 'config/'")
        except IOError:
            raise Exception("Certificate cannot open")

    @staticmethod
    def get_appmeta_et_root():
        if Types.__appmeta_et_root:
            return Types.__appmeta_et_root
        if os.path.isfile(os.environ['APP_PATH'] + NAME_FILE_APP_META):
            tree_appmeta = ET.parse(os.environ['APP_PATH'] + NAME_FILE_APP_META)
        else:
            uri_appmeta = aps2.Info.Info.get_BODY_JSON()["aps"]["package"]["href"] + '/APP-META.xml'
            tree_appmeta = aps2.InfoParse.InfoParse.get_APS_API().GET(uri_appmeta, None, None, aps2.InfoParse.InfoParse.get_PATH_CERTIFICATE(), False)
            # this 'write' write tree_appmeta with prefix = 'ns0'
            tree_appmeta.write(os.environ['APP_PATH'] + NAME_FILE_APP_META)
        Types.__appmeta_et_root = tree_appmeta.getroot()
        return Types.__appmeta_et_root

    @staticmethod
    def delete():
        Types.__application_services_json = None
        Types.__appmeta_et_root


