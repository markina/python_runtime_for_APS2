import os
import simplejson as json
import ordereddict

import aps2.apsapi
import aps2.uLogging

NAME_FILE_LIST_SERVICES = 'list_services.json'


class Types:
    __application_service_json = None
    __schema_json = None
    __appmeta_et_root = None

    def __init__(self):
        pass

    def get_application_service_json(self, hpr):
        """
        Return json from cache NAME_FILE_LIST_SERVICES or from controller with call aps2.apsapi.API.APS_API.GET()
        It's stored information about services. For example:
        "aps": {
                "endpoint": "https://endpoint.a.apscloudstest.apsdemo.org:443/endpoint000/",
                "id": "022183f5-0945-4465-952b-95ef4e92ac8b",
                "type": "http://aps-standard.org/samples/starter"
        },
        "clouds": {
                "name": "VPS cloud globals",
                "schema": "/aps/2/types/90",
                "summary": "VPS cloud application global service",
                "type": "http://aps-standard.org/samples/starter/cloud/1.0"
        },
        "contexts": {
                "name": "VPS Management",
                "schema": "/aps/2/types/91",
                "summary": "VPS management environment",
                "type": "http://aps-standard.org/samples/starter/context/1.0"
        }
        """
        # logger.info("get_get_application_services:")
        if self.__application_services:
            return self.__application_service_json

        if os.path.isfile(os.environ['APP_PATH'] + NAME_FILE_LIST_SERVICES):
            # logger.info("list_services.json EXIST!")
            with open(os.environ['APP_PATH'] + NAME_FILE_LIST_SERVICES) as inFile:
                application_services = json.loads(inFile.read(), object_pairs_hook=ordereddict.OrderedDict)
        else:
            # logger.info("list_services.json NOT exist!")
            application_services = aps2.apsapi.API.APS_API.GET(
                '/aps/2/application', None, None, Types.get_apsc_pem_certificate_path(hpr)
            )
            with open(os.environ['APP_PATH'] + NAME_FILE_LIST_SERVICES, 'wb') as outfile:
                outfile.write(json.dumps(application_services, indent=8))
        # logger.info("application_services:")
        # logger.info(json.dumps(application_services, indent=8))
        self.__application_service_json = application_services
        return application_services

    @staticmethod
    def get_pem_certificate_path(hpr):
        return os.environ['APP_PATH'] + '/config/' + str(hpr.HTTP_APS_INSTANCE_ID) + '.pem'

    @staticmethod
    def get_apsc_pem_certificate_path(hpr):
        return os.environ['APP_PATH'] + '/config/' + str(hpr.HTTP_APS_INSTANCE_ID) + '.apsc.pem'

    @staticmethod
    def save_certificate(hpr):
        """
        The certificate is stored in the call POST
        It used when a standard call
        """
        aps_self = hpr.body_json["aps"]["x509"]["self"]
        aps_controller = hpr.body_json["aps"]["x509"]["controller"]
        try:
            dir_config = os.environ['APP_PATH'] + 'config/'
            if not os.path.exists(dir_config):
                os.makedirs(dir_config)
            with open(Types.get_pem_certificate_path(hpr), 'w') as outfile:
                outfile.write(aps_self)
            with open(Types.get_apsc_pem_certificate_path(hpr), 'w') as outfile:
                outfile.write(aps_controller)
        except OSError:
            raise Exception("Cannot make directory 'config/'")
        except IOError:
            raise Exception("Certificate cannot open")


