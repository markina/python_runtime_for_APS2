import re
import urllib2


import aps2.function


STRING = "string"
INTEGER = "integer"
BOOLEAN = "boolean"
NUMBER = "number"


class Obj(object):
    pass


class PathVerb(object):
    def __init__(self, path, verb):
        self.path = path
        self.verb = verb


def get_valid_path_verbs(tree_schemas):
    list_valid_paths = []

    for oper in tree_schemas.schema[0].get("operations", []):
        path = tree_schemas.schema[0]["operations"][oper]["path"]
        verb = tree_schemas.schema[0]["operations"][oper]["verb"]
        list_valid_paths.append(PathVerb(path, verb))

    for impl in tree_schemas.list_schema:
        list_valid_paths.extend(get_valid_path_verbs(impl))

    return list_valid_paths


def is_match(path_verb, REQUEST_METHOD, PATH_INFO):
    if path_verb.verb != REQUEST_METHOD:
        return False

    pattern = get_pattern_by_path(path_verb.path)
    if pattern.match(PATH_INFO):
        return True
    else:
        return False


def find_appropriate_path_verbs(list_valid_path_verbs, parsed_environ):
    for pv in list_valid_path_verbs:
        if is_match(pv, parsed_environ.get("REQUEST_METHOD"), parsed_environ.get("PATH_INFO")):
            return pv
    raise Exception("Not found appropriate path and verb for PATH_INFO: " + parsed_environ.get("PATH_INFO"))


def get_pattern_by_path(path):
    if path.find('{') != -1:
        name_in_path = path[:path.find('{')-1]         # name_in_path = "/calculateSomething"
        params_in_path = path[len(name_in_path)+1:]       # params_in_path = "{pathparam}/{ps}"
        re_valid_pattern = name_in_path
        for param_i in re.split("/", params_in_path):
            param_i = param_i[1:len(param_i)-1]
            re_valid_pattern += "/(?P<" + param_i + ">[0-9a-zA-Z_]*)"  # TODO fix [a-zA-Z][0-9a-zA-Z_]*
    else:
        re_valid_pattern = path

    re_valid_pattern = "(/.+)?(/[\w-]{36})?" + re_valid_pattern

    return re.compile(re_valid_pattern)


def get_function_description(parsed_environ, current_service):
    list_valid_paths = get_valid_path_verbs(current_service.tree_schemas)
    path_verb = find_appropriate_path_verbs(list_valid_paths, parsed_environ)

    return get_FuncDesc_by_path_verb(path_verb, current_service.tree_schemas)


def get_FuncDesc_by_path_verb(path_verb, tree_schemas):
    for oper in tree_schemas.schema[0].get("operations", []):
        path = tree_schemas.schema[0]["operations"][oper]["path"]
        verb = tree_schemas.schema[0]["operations"][oper]["verb"]
        if verb == path_verb.verb and path == path_verb.path:
            return aps2.function.FunctionDescription(tree_schemas.schema[0]["operations"][oper], oper)

    for impl in tree_schemas.list_schema:
        func_desc = get_FuncDesc_by_path_verb(path_verb, impl)
        if func_desc:
            return func_desc


def get_constructor(types, service):
    class_name = service.tree_schemas.schema["name"]
    appmeta_namespace = re.search('\{(.*)\}', types.appmeta.tag).group(1)
    services = types.appmeta.findall(".//{" + appmeta_namespace + "}service")

    script_path = ""
    for service in services:
        if service.get('id') == service.name:
            script_path = service.findall(".//{" + appmeta_namespace + "}code")[0].get('path')  # TODO
            script_path = script_path[script_path.find('/')+1:script_path.rfind('.')]
            break
    import_script = __import__(script_path)
    constructor = getattr(import_script, class_name)

    return constructor


class Property(object):
    def __init__(self, name, json):
        self.name = name
        self.json = json


def get_properties(schema):
    properties = []
    json_properties = schema[0]["properties"]
    for prop in json_properties.items():
        properties.append(Property(prop[0], json_properties[prop[0]]))
    return properties


def get_aps_id(name_service, PATH_INFO):
    len_service_id = len('/' + name_service + '/')
    if len_service_id > len(PATH_INFO):
        return "NOT_SET"
    string_without_service_id = PATH_INFO[len_service_id:]
    pattern = re.compile('[\w-]{36}')
    if pattern.match(string_without_service_id):
        aps_id = string_without_service_id[:36]
        return aps_id
    else:
        return "NOT_SET"


def load_application_object(parsed_environ, types, service, function_description):
    constructor = get_constructor(types, service)

    if function_description.json.get("static", "false") == "true":
        return constructor

    resource = constructor()
    properties = get_properties(service.schema)

    # if verb == POST: content not exist. Content should loud from body,
    # else : loud content with APS_API.GET(aps_id) and full resource
    if function_description.json["verb"] == "POST" and function_description.json["path"] == "/":
        content = parsed_environ.get("BODY")
    else:
        content = types.get_resource(get_aps_id(service.name, parsed_environ.get("PATH_INFO")))

    for prop in properties:
        setattr(resource, prop, get_obj_by_type(content[prop.name], prop.json["type"]))

    return resource


def str2bool(v):
    return v.lower() in ("true", "t", "1")


def get_obj_by_complex_type(value, type_param, current_structures):  # TODO FIX
    return None


def get_obj_by_type(value, type_param, current_structures=None):
    if type_param == STRING:
        return urllib2.unquote(value)
    elif type_param == INTEGER:
        return int(value)
    elif type_param == BOOLEAN:
        return str2bool(value)
    elif type_param == NUMBER:
        return float(value)
    else:
        obj = get_obj_by_complex_type(value, type_param, current_structures)
        return obj

