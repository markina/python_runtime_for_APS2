import os
import re

import aps2.apsapi
import aps2.printer
import aps2.ServiceId
import aps2.Types

import simplejson as json
import ordereddict

SUFFIX_NF_SCHEMA = '.schema'

logger = aps2.uLogging.get_logger('/tmp/myapp.log', aps2.uLogging.DEBUG)


class Helper:
    def __init__(self):
        pass

    def __getattr__(self, attr):
        try:
            return self.arrt
        except AttributeError:
            raise AttributeError("AttributeError: %r is not set!" % attr)

    def put_environ(self, environ):
        self.REQUEST_METHOD = environ.get('REQUEST_METHOD', 0)
        self.REQUEST_URI = environ.get('REQUEST_URI', 0)
        logger.info("REQUEST_URI = " + self.REQUEST_URI)
        self.SCRIPT_NAME = environ.get('SCRIPT_NAME', 0)
        logger.info("SCRIPT_NAME = " + self.SCRIPT_NAME)
        self.HTTP_APS_CONTROLLER_URI = environ.get('HTTP_APS_CONTROLLER_URI', 0)
        logger.info("HTTP_APS_CONTROLLER_URI = " + self.HTTP_APS_CONTROLLER_URI)
        self.HTTP_APS_INSTANCE_ID = environ.get('HTTP_APS_INSTANCE_ID', 0)
        logger.info("HTTP_APS_HTTP_APS_INSTANCE_ID = " + self.HTTP_APS_INSTANCE_ID)
        self.APS_API = aps2.apsapi.API(self.HTTP_APS_CONTROLLER_URI)
        logger.info("APS_API = " + str(self.APS_API))
        self.PATH_CERTIFICATE = os.environ['APP_PATH'] + '/config/' + str(self.HTTP_APS_INSTANCE_ID) + '.pem'
        logger.info("PATH_CERTIFICATE = " + self.PATH_CERTIFICATE)
        self.PATH_INFO = environ.get('PATH_INFO', 0)
        logger.info("PATH_INFO = " + self.PATH_INFO)
        self.QUERY_STRING = environ.get("QUERY_STRING", 0)
        logger.info("QUERY_STRING = " + self.QUERY_STRING)

        self.environ = environ
        logger.info("environ = " + "...")

        self.CONTENT_LENGTH = self.get_request_length()
        logger.info("CONTENT_LENGTH = %d", self.CONTENT_LENGTH)
        if self.CONTENT_LENGTH != 0:
            self.body = environ['wsgi.input'].read(self.CONTENT_LENGTH)
            self.body_json = json.loads(self.body, object_pairs_hook=ordereddict.OrderedDict)
            logger.info("body_json = " + "...")

        # self.service_id = self.get_service_id()
        # self.service_id.log_to_string()

        self.aps_id = self.get_aps_id()
        logger.info("aps_id = " + str(self.aps_id))
        self.current_function = self.get_current_function()
        logger.info("current_function = " + self.current_function)
        self.schema_json = self.get_schema()
        logger.info("schema_json = " + "...")

    def get_request_length(self):
        try:
            request_body_size = int(self.environ.get('CONTENT_LENGTH', 0))
        except ValueError:
            request_body_size = 0
        return request_body_size

    # def get_service_id(self):
    #     # 'get_service_id' get current_service_id by PATH_INFO
    #     # For example:
    #     # /clouds/0f9b79e1-de01-4af6-9ff6-ccc589b11978/createCounter/pathparam1
    #     # =>
    #     # ServiceId(main_name=clouds, json=...)
    #     # logger.info("PATH_INFO:")
    #     # logger.info(hpr.PATH_INFO)
    #     service_id = None
    #     for item in aps2.Types.Types.get_application_services_json(self):
    #         # logger.info("item = " + item)
    #         pattern = re.compile('/' + item)
    #         if pattern.match(self.PATH_INFO):
    #             service_id = aps2.service_id.ServiceId()
    #             service_id.json = aps2.Types.Types.get_application_services_json(self)[item]
    #             service_id.main_name = item
    #             break
    #
    #     if service_id is None:
    #         raise Exception("Error: service_id in PATH_INFO not exist!")
    #     # logger.info("service_id :")
    #     # logger.info("main_name = " + service_id.main_name)
    #     # logger.info("json = " + json.dumps(service_id.json, indent=8))
    #     return service_id

    def get_schema(self):
        # 'get_schema' get json from 'same_name.schema'
        # or from APS_API
        # it's full information about service. For example:
        # {
        # "aps": {
        #         "href": "https://apsc.aps-standard.org/types/90",
        #         "id": "90"
        # },
        # "apsVersion": "2.0",
        # "id": "http://aps-standard.org/samples/starter/cloud/1.0",
        # "implements": [
        #         "http://aps-standard.org/types/core/application/1.0"
        # ],
        # "name": "cloud",
        # "operations": {
        #         "calculateSomething": {
        #                 "parameters": {
        #                         "paramA": {
        #                                 "kind": "query",
        #                                 "type": "integer"
        #                         }
        #                 },
        #                 "path": "/calculateSomething/{paramX}",
        #                 "response": {
        #                         "type": "string"
        #                 },
        #                 "verb": "GET"
        #         }
        # }
        dir_schemas = os.environ['APP_PATH'] + 'schemas/'
        if not os.path.exists(dir_schemas):
            os.makedirs(dir_schemas)
        nf_schema = aps2.ServiceId.ServiceId.get_name_service_id(self) + SUFFIX_NF_SCHEMA
        if os.path.isfile(dir_schemas + nf_schema):
            # logger.info(nf_schema + " EXIST!")
            with open(dir_schemas + nf_schema) as infile:
                schema = json.loads(infile.read(), object_pairs_hook=ordereddict.OrderedDict)
        else:
            # logger.info(nf_schema + " NOT exist!")
            schema = self.APS_API.GET(
                "/aps/2/types/?id=" + aps2.ServiceId.ServiceId.get_json_service_id(self)["type"],
                None, None, self.PATH_CERTIFICATE
            )
            with open(dir_schemas + nf_schema, 'wb') as outfile:
                outfile.write('%s' % schema)
        return schema[0]

    def get_aps_id(self):
        # For example:
        # /clouds/0f9b79e1-de01-4af6-9ff6-ccc589b11978/createCounter/pathparam1
        # =>
        # "0f9b79e1-de01-4af6-9ff6-ccc589b11978"
        len_service_id = len('/' + aps2.ServiceId.ServiceId.get_name_service_id(self) + '/')
        if len_service_id > len(self.PATH_INFO):
            # logger.info("length /service_id/ > len(hpr.PATH_INFO)")
            # logger.info("=> PATH_INFO not consist aps_id")
            return None
        string_without_service_id = self.PATH_INFO[len_service_id:]
        # logger.info("string_without_service_id = " + string_without_service_id)
        pattern = re.compile('[\w-]{36}')
        if pattern.match(string_without_service_id):
            aps_id = string_without_service_id[:36]
            # logger.info("aps_id = " + aps_id)
            return aps_id
        return None

    def get_current_function(self):
        # For example:
        # /clouds/0f9b79e1-de01-4af6-9ff6-ccc589b11978/createCounter/pathparam1
        # =>
        # "/createCounter/pathparam1"
        if self.aps_id:
            len_service_id_aps_id = len('/' + aps2.ServiceId.ServiceId.get_name_service_id(self) + '/' + self.aps_id)
            current_function = self.PATH_INFO[len_service_id_aps_id:]
        else:
            len_service_id = len('/' + self.service_id.main_name + '/')
            current_function = self.PATH_INFO[len_service_id:]
        return current_function






