import os
import re

import aps2.apsapi
import aps2.printer
import aps2.service_id

import simplejson as json
import ordereddict


NF_LIST_SERVICES = 'list_services.json'
SUFFIX_NF_SCHEMA = '.schema'

logger = aps2.uLogging.get_logger('/tmp/myapp.log', aps2.uLogging.DEBUG)


class Helper:
    def __init__(self):
        pass

    def __getattr__(self, attr):
        try:
            return self.arrt
        except AttributeError:
            raise AttributeError("AttributeError: %r is not set!" % attr)

    def put_environ(self, environ):
        self.REQUEST_METHOD = environ.get('REQUEST_METHOD', 0)
        self.REQUEST_URI = environ.get('REQUEST_URI', 0)
        logger.info("REQUEST_URI = " + self.REQUEST_URI)
        self.SCRIPT_NAME = environ.get('SCRIPT_NAME', 0)
        logger.info("SCRIPT_NAME = " + self.SCRIPT_NAME)
        self.HTTP_APS_CONTROLLER_URI = environ.get('HTTP_APS_CONTROLLER_URI', 0)
        logger.info("HTTP_APS_CONTROLLER_URI = " + self.HTTP_APS_CONTROLLER_URI)
        self.HTTP_APS_INSTANCE_ID = environ.get('HTTP_APS_INSTANCE_ID', 0)
        logger.info("HTTP_APS_HTTP_APS_INSTANCE_ID = " + self.HTTP_APS_INSTANCE_ID)
        self.APS_API = aps2.apsapi.API(self.HTTP_APS_CONTROLLER_URI)
        logger.info("APS_API = " + str(self.APS_API))
        self.PATH_CERTIFICATE = os.environ['APP_PATH'] + '/config/' + str(self.HTTP_APS_INSTANCE_ID) + '.pem'
        logger.info("PATH_CERTIFICATE = " + self.PATH_CERTIFICATE)
        self.PATH_INFO = environ.get('PATH_INFO', 0)
        logger.info("PATH_INFO = " + self.PATH_INFO)
        self.QUERY_STRING = environ.get("QUERY_STRING", 0)
        logger.info("QUERY_STRING = " + self.QUERY_STRING)

        self.environ = environ
        logger.info("environ = " + "...")

        self.CONTENT_LENGTH = self.get_request_length()
        logger.info("CONTENT_LENGTH = %d", self.CONTENT_LENGTH)
        if self.CONTENT_LENGTH != 0:
            self.body = environ['wsgi.input'].read(self.CONTENT_LENGTH)
            self.body_json = json.loads(self.body, object_pairs_hook=ordereddict.OrderedDict)
            logger.info("body_json = " + "...")

        self.application_services_json = self.get_application_services_json()
        aps2.printer.print_line()
        aps2.printer.print_json("application_services_json = ", self.application_services_json)
        aps2.printer.print_line()

        self.service_id = self.get_service_id()
        self.service_id.log_to_string()

        self.aps_id = self.get_aps_id()
        logger.info("aps_id = " + str(self.aps_id))
        self.current_function = self.get_current_function()
        logger.info("current_function = " + self.current_function)
        self.schema_json = self.get_schema()
        logger.info("schema_json = " + "...")

    def get_request_length(self):
        try:
            request_body_size = int(self.environ.get('CONTENT_LENGTH', 0))
        except ValueError:
            request_body_size = 0
        return request_body_size

    def get_application_services_json(self):
        # 'get_application_services' get json from 'list_services.json'
        # or from APS_API
        # it's information about services. For example:
        # "aps": {
        #         "endpoint": "https://endpoint.a.apscloudstest.apsdemo.org:443/endpoint000/",
        #         "id": "022183f5-0945-4465-952b-95ef4e92ac8b",
        #         "type": "http://aps-standard.org/samples/starter"
        # },
        # "clouds": {
        #         "name": "VPS cloud globals",
        #         "schema": "/aps/2/types/90",
        #         "summary": "VPS cloud application global service",
        #         "type": "http://aps-standard.org/samples/starter/cloud/1.0"
        # },
        # "contexts": {
        #         "name": "VPS Management",
        #         "schema": "/aps/2/types/91",
        #         "summary": "VPS management environment",
        #         "type": "http://aps-standard.org/samples/starter/context/1.0"
        # }
        # logger.info("get_get_application_services:")
        if os.path.isfile(os.environ['APP_PATH'] + NF_LIST_SERVICES):
            # logger.info("list_services.json EXIST!")
            with open(os.environ['APP_PATH'] + NF_LIST_SERVICES) as inFile:
                application_services = json.loads(inFile.read(), object_pairs_hook=ordereddict.OrderedDict)
        else:
            # logger.info("list_services.json NOT exist!")
            application_services = self.APS_API.GET('/aps/2/application', None, None, self.PATH_CERTIFICATE)
            with open(os.environ['APP_PATH'] + NF_LIST_SERVICES, 'wb') as outfile:
                outfile.write(json.dumps(application_services, indent=8))
        # logger.info("application_services:")
        # logger.info(json.dumps(application_services, indent=8))
        return application_services

    def get_service_id(self):
        # 'get_service_id' get current_service_id by PATH_INFO
        # For example:
        # /clouds/0f9b79e1-de01-4af6-9ff6-ccc589b11978/createCounter/pathparam1
        # =>
        # ServiceId(main_name=clouds, json=...)
        # logger.info("PATH_INFO:")
        # logger.info(hpr.PATH_INFO)
        service_id = None
        for item in self.application_services_json:
            # logger.info("item = " + item)
            pattern = re.compile('/' + item)
            if pattern.match(self.PATH_INFO):
                service_id = aps2.service_id.ServiceId()
                service_id.json = self.application_services_json[item]
                service_id.main_name = item
                break

        if service_id is None:
            raise Exception("Error: service_id in PATH_INFO not exist!")
        # logger.info("service_id :")
        # logger.info("main_name = " + service_id.main_name)
        # logger.info("json = " + json.dumps(service_id.json, indent=8))
        return service_id

    def get_schema(self):
        # 'get_schema' get json from 'same_name.schema'
        # or from APS_API
        # it's full information about service. For example:
        # {
        # "aps": {
        #         "href": "https://apsc.aps-standard.org/types/90",
        #         "id": "90"
        # },
        # "apsVersion": "2.0",
        # "id": "http://aps-standard.org/samples/starter/cloud/1.0",
        # "implements": [
        #         "http://aps-standard.org/types/core/application/1.0"
        # ],
        # "name": "cloud",
        # "operations": {
        #         "calculateSomething": {
        #                 "parameters": {
        #                         "paramA": {
        #                                 "kind": "query",
        #                                 "type": "integer"
        #                         }
        #                 },
        #                 "path": "/calculateSomething/{paramX}",
        #                 "response": {
        #                         "type": "string"
        #                 },
        #                 "verb": "GET"
        #         }
        # }
        dir_schemas = os.environ['APP_PATH'] + 'schemas/'
        if not os.path.exists(dir_schemas):
            os.makedirs(dir_schemas)
        nf_schema = self.service_id.main_name + SUFFIX_NF_SCHEMA
        if os.path.isfile(dir_schemas + nf_schema):
            # logger.info(nf_schema + " EXIST!")
            with open(dir_schemas + nf_schema) as infile:
                schema = json.loads(infile.read(), object_pairs_hook=ordereddict.OrderedDict)
        else:
            # logger.info(nf_schema + " NOT exist!")
            schema = self.APS_API.GET("/aps/2/types/?id=" + self.service_id.type, None, None, self.PATH_CERTIFICATE)
            with open(dir_schemas + nf_schema, 'wb') as outfile:
                outfile.write('%s' % schema)
        return schema[0]

    def get_aps_id(self):
        # For example:
        # /clouds/0f9b79e1-de01-4af6-9ff6-ccc589b11978/createCounter/pathparam1
        # =>
        # "0f9b79e1-de01-4af6-9ff6-ccc589b11978"
        len_service_id = len('/' + self.service_id.main_name + '/')
        if len_service_id > len(self.PATH_INFO):
            # logger.info("length /service_id/ > len(hpr.PATH_INFO)")
            # logger.info("=> PATH_INFO not consist aps_id")
            return None
        string_without_service_id = self.PATH_INFO[len_service_id:]
        # logger.info("string_without_service_id = " + string_without_service_id)
        pattern = re.compile('[\w-]{36}')
        if pattern.match(string_without_service_id):
            aps_id = string_without_service_id[:36]
            # logger.info("aps_id = " + aps_id)
            return aps_id
        return None

    def get_current_function(self):
        # For example:
        # /clouds/0f9b79e1-de01-4af6-9ff6-ccc589b11978/createCounter/pathparam1
        # =>
        # "/createCounter/pathparam1"
        if self.aps_id:
            len_service_id_aps_id = len('/' + self.service_id.main_name + '/' + self.aps_id)
            current_function = self.PATH_INFO[len_service_id_aps_id:]
        else:
            len_service_id = len('/' + self.service_id.main_name + '/')
            current_function = self.PATH_INFO[len_service_id:]
        return current_function






